The book of computing nonsense.


Computer manual & art of distributed systems.

AFORISMOS QUE DISCURREN EN LA COMPUTACIÓN DE PRINCIPIOS DEL SIGLO XXI

Analogy
Analogia, “proportion”

Is a cognitive process of transferring information or meaning from a particular subject the analogue or source to another the target to such a process.

In a narrower sense, analogy is an inference or an argument from one particular to another particular, as opposed to deduction, induction, and abduction, where at least one of the premises or the conclusion is general.

The word analogy can also refer to the relation between the source and the target themselves, which is often, though not necessarily, similarity. (WTF)

Analogy and problem solving
Analogy plays a significant role in problem solving such as decision making, perception, memory, creativity, emotion, explanation, and communication.

It is behing basic tasks such as the identification of places, objects and people for example in face perception and facial recognition systems.

It has been argued that analogy is the core of cognition.

Specific analogical language comprises exemplification, comparisons, metaphors, similes, allegories, and parables, but not metonymy.

Phrases like and so on, and the like, as if, and the very word like also rely on an analogical understanding by the receiver of a message including them.

Analogy is important not only in ordinary language and common sense where proverbs and idioms give many examples of its application but also in science, philosophy, and the humanities.

On Analogy
The concepts of association, comparison, correspondence, mathematical and morphological homology, homomorphism, iconicity, isomorphism, metaphor, resemblance, and similarity are closely related to analogy.

In Cognitive linguistics, the notion of conceptual metaphor may be equivalent to that of analogy.

Source and target
With respect to the term source and target there are two distinct traditions of usage:

The logical and cultures and economics tradition speaks of an arrow, homomorphism, mapping, or morphism from what is typically the more complex domain or source to what is typically the less complex codomain or target, using all of these words in the sense of mathematical category theory.


The traditional in cognitive psychology in literary theory, and in specialization within in philosophy outside of logic speaks of a mapping from what typically the more familiar area of experience the source, to what is typically the more problematic are of experience, the target.

Identity of relation
In ancient Greek the word analogia originally meant proportionality, in the mathematical sense, and, it was indeed sometimes translated to Latin as proportion.

From there analogy was understood as identity of relation between any two ordered pairs, whether of mathematical nature or not.
Shared abstraction
Greek philosophers such as Plato and Aristotle actually used a wider notion of analogy.

They saw analogy as a shared abstraction.

Analogous objects did not share necessarily a relation, but also an idea, a pattern, a regularity, an attribute, an effect or a philosophy.

These authors also accepted that comparisons, metaphors and “images” (allegories) could be used as arguments, and sometimes they called them analogies.

Analogies should also make the abstraction easier to understand and give confidence to ones using them.


Analogy In Science
Analogues are often used in theoretical and applied sciences in the form of models or simulations which can be considered as strong analogies.

Other much weaker analogies assist in understanding and describing functional behaviours of similar systems.

Analogy in Mathematics
Some types of analogies can have a precise mathematical formulation through the concepts of isomorphism.

In detail, this means that given two mathematical structures of the same type, an analogy between them can be thought of as a bijection between them which preserves some or all the relevant structure.

Category theory takes the idea of mathematical analogy much further with the concept of functors.

Nouns

A noun is a word for a person, place, or thing.

You might like to think of nouns as naming words.

Everything we can see or talk about is represented by a word which names it.

That “naming word” is called a noun.

Sometimes a noun will be the name for something we can touch and sometimes a noun will be the name for something we cannot touch.

Everything is represented by a word that lets us talk about it.

This includes people, animals, objects, qualities, actions, and measures.

Noun

A noun is a word that functions as the name of some specific thing or set of things, such as living creatures, objects, places, actions, qualities, states of existence, or ideas.

Linguistically, a noun is a member of a large, open part of speech whose members can occur as the main word in the subject of a clause, the object of a verb, or the object of a preposition.

Lexical categories “parts of speech” are defined in terms of the ways in which their members combine with other kinds of expressions.

The syntactic rules for nouns are those words which can occur with articles and attributive adjectives and can function as the head of a noun phrase.

Specialised algorithms

Combine and optimise algorithms in real-time, with no redeploy to test configurations and strategies.

Ability to apply multiple algorithms.

Change algorithm configuration in real time with no redeployment.

Combine with domain-specific business logic.

Pluggable architecture to integrate your in-house algorithms using common interface.

Semaphores

In multithreaded programming, it’s important to make threads wait.

They must wait for exclusive access to a resource.

They must wait when there’s no work available.

One wait to make threads wait and put them to sleep inside the kernel, so that they no longer take any CPU time, is with a semaphore.

Using only semaphores and atomic operations, it's possible to implement all of the following primitives:

a lightweight mutex
a lightweight auto-reset event object
a lightweight read-write lock
Another solution to the dining philosophers
A lightweight semaphore with partial spinning

A semaphore is like a bouncer

Imagine a set of waiting threads, line up in a queue - much like a lineup in front of a busi nightclub or theatre.

a semaphore is like a bouncer at the front- of the lineup.

he only allows, threads to proceed when instructed to do so.

Each thread decides for itself when to join the queue. In a modern semaphore implementation, you're likely to see this operation called wait.

basically, when a thread calls the semaphores wait operation, it enters the lineup.

Dashboards

Analytics, used by a developer or operations person usually to help troubleshoot performance issues with the service.

Whenever we talk to anyone they immediately assume we’re talking about this type of dashboard. You’ll use this type to correlate, aggregate, chain mathematical functions and try to coerce streams of data intro discernible patterns with the hope you’ll uncover something that need fixing.

NOC Dashboards

Their audience is generally a group of highly technical people sitting very close to them.

Mostly these run monitoring tools, host status pages, or in some cases something like Moonwinds.

Any big 404’s are quite noticeable.

Team Dashboards

Usually rotating browser tabs showing things the team want to see to help them run a better online service.

We see a lot of different tools that give an idea of number of users online, or marketing type data.

Public Dashboards

These are generally very simplified, quite sanitised dashboards

Consider Coroutines

To run many functions concurrently

Threads give a way to run multiple functions seemingly at the same time.

But there are three big problems with threads:
they require special tools to coordinate with each other safely. This makes code that uses threads harder to reason about than procedural, single-threaded code.

This complexity makes threaded code more difficult to extend and maintain over time.


Threads require a lot of memory, about 8MB per executing thread. On many computers, that amount of memory doesn’t matter for a dozen threads or so.. but what if you want your program to run tens of thousands of functions “simultaneously” ?

Running a thread per unique activity just won’t work.


Threads are costly to start. If you want to constantly be creating new concurrent functions and finishing them, overhead of using threads become large and slows everything down.

Julia, Python and Lua can work around all these issues with coroutines. Coroutines let you have many seemingly simultaneous functions in your servers.

Coroutines, things to remember

Coroutines provide an efficient way to run tens of thousands of functions seemingly at the same time.

Coroutines give you a powerful tool for separating the core logic of your program from its interaction with the surrounding environment.

Battles are fought in real time, and usually involve maneuvering

To land blows using melee weapons as well as casting offensive range magic spells.

The sun light tool has been a recurring element in every world as well as items such as the Earth Herb and Antidote.

Users take control of the main character who, at the start of the game, can be customized by choice of gender appearance, name and starting class.

There are (N) starting classes, ranging from ____.

Each class has its own starting statistics, gear, weapons and type of magic used which all emphasize certain approaches to combat depending of the user's preference.

As users monkeys kill daemons, they gain souls which act as currency that can be used to buy, repair, and upgrade weapons as well as increase user statistics.

Along with souls, users can retrieve items such as weaponry and ore from upgrading.

When a user is killed during a level, they are sent returns in souls form with lower maximum health and the loss of all unused souls.

If the user manages to reach their bloodstain at the point where they were last killed, they ragin they lost souls.

Upon defeating a boss, the user can choose to re-spawn back to that location, marked in the form of an archstone.

When not exploring a level, users reside in the Nexus, a realm of souls that acts as a hub where users can exchange souls, store items and travel between regions.

After completing the initial portion of the first region players can choose to progress through any other of the newly available regions.

The Five Good Emperors

The rulers commonly known as the “Five Good Emperors” were Nerva, Trajan, Hadrian, Antoninus Pius and Marcus Aurelius.

The term FIve Good Emperors was coined by the political philosopher Niccolo Machiavelli in 1503.

From the study of this history we may also learn how a good government is to be established; for while all the emperors who succeeded to the throne by birth except Titus, were bad, all were good who succeeded by adoption, as in the case of the five from Nerva to Marcus.

But as soon as the empire fell once more to the heirs by birth, its ruin recommenced.

Machiavelli argued that these adopted emperors, through good rule, earned the respect of those around them:

Titus, Nerva, Trajan, Hadrian, Antoninus and Marcus had no need of pretorian cohorts, or countless legions to guard them, but were defended by their own good lives, the good-will of their subjects, and the attachment of the senate.

Heuristic

A Heuristic technique Greek: find or discover, sometimes called simple a heuristic, is any approach to problem solving, learning, or discovery that employs a practical methodology not guaranteed to be optimal or perfect, but sufficient for the immediate goals.

Where finding an optimal solution is impossible or impractical heuristic methods can be used to speed up the process of finding a satisfactory solution.

Heuristics can be mental shortcuts that ease the cognitive load of making a decision.
Examples of this method include using a rule of thumb an educated guess, an intuitive judgment, stereotyping, profiling, or common sense.

More precisely, heuristics are strategies

Using readily accessible, though loosely applicable, information to control problem solving in human beings and machines.

The most fundamental heuristic is trial and error, which can be used in everything from matching nuts and bolts to finding the values of variables in algebra problems.

if you are having difficulty understanding a problem, try drawing a picture.
if you can’t find a solution, try assuming that you have a solution and seeing what you can derive from that “working backward”.
if the problem is abstract, try examining a concrete example.
Try solving a more general problem first; the “inventor's paradox”: The more ambitious plan may have more chances of success.

Heuristic is also often used as noun to describe a rule-of-thumb, procedure, or method.

Both individuals and organizations rely on heuristics in an adaptive way.

They also found that ignoring part of the information with decision rather weighing all the options, can actually lead to more accurate decisions.

Message queues and mailboxes

Software components used for inter-process communication (IPC).

They use a queue for messaging the passing of control or content.

Group communication systems provide similar kinds of functionality.

Message queues provide an asynchronous communication protocol, meaning that the sender and receiver of the message do not need to interact with the message queue at the same time.

Messages placed onto the queue are stored until the recipient retrieves them.

Message queues have implicit or explicit limits on the size of data that may be transmitted in a single message and the number of messages that may remain outstanding on the queue.

Other implementations allow the passing of messages between different computer systems potentially connecting multiple operating systems.

These message queuing systems typically provide enhanced resilience functionality to ensure that messages do not get lost in the event of system failure.

Programming Erlang

The Erlang programming language uses processes to provide concurrency; these processes communicate asynchronously using message passing.

Unix message passing implementation

Unix implements message passing keeping an array of linked lists as message queues.

Each message queue is identified by its index in the array, and has a unique descriptor.

A given index can have multiple possible descriptors.

Unix gives standard functions to access the message passing feature.

msgget(): this system call takes a key as an argument and returns a descriptor of the queue with the matching key if it exists.

if it does not exist, and the IPC_CREAT flag is set, it makes a new message queue with the given key and returns its descriptor.


msgrcv(): Used to receive a message from a given queue descriptor.

The caller process must have read permission for the queue.

It is of two types:

- Blocking receive puts the child to sleep if it cannot find a requested message type. It sleeps till another message is posted in the queue, and then wakes up to check again.

- Non-blocking receive returns immediately to the caller, mentioning that it failed.


msgctl(): Used to change message queue parameters like the owner.

Most importantly it is used to delete the message queue by passing the IPC_RMID flag.

A message queue can be deleted only by its creator, owner, or the superuser.

Conway’s Law

Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. - M. Conway


Coroutines again

Computer system components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations.

Coroutines are well-suited for implementing more familiar program components such as cooperative tasks, exceptions, event loop, iterators, infinite lists and powerful pipes.

Bus

In computer architecture, a bus related to the latin omnibus, meaning “for all” is a communication system that transfers data between components inside a computer, or between computers.

This expression covers all related hardware components and software communication protocols.

Event Monitoring

The process of collecting, analysing, and signalling event occurrences to subscribers such as operating system processes, databases, as well as human operators.

Event monitoring makes use of a logical bus to transport event occurrences from source to subscribers, where event sources signal event occurrences to all event subscribers receive event occurrences.

A eventbus can be distributed over a set of physical nodes such as standalone computer systems.

Event collection is the process of collecting event occurrences in a filtered event log for analysis. A filtered event log is a logged event occurrences that can be of meaningful use in the future; this implies that event occurrences can be removed from the filtered event log to aggregate event occurrences or to decide whether or not an event occurrence should be signalled.

Event signalling is the process of signalling event occurrences over the event bus.

Imps of Ceres

Units under the control of the system emit mechanical snarls, means and screeches after the process of spawning a unit is complete there is a alert message indicating that a uit was just created, each unit grunts in different ways and makes different noises when selected.

Law of the instrument

I call the law of the instrument, and if may be formulated as follows: Give a small boy a hammer, and he will find that everything he encounters needs pounding. - 1964, Abram Kaplan

Unix Power Tools

Unix pipes are an extremely elegant way to interface information programs and do inter-process communication in general.

The chainsaw analogy works great: people sometimes fear doing work in Unix because it’s a powerful tool, and it;s easy to screw up with powerful tools.

In the process of doing some stuffs it;s not uncommon to ask “is this clever and elegant? or completely fucking stupid?” this is normal, unix is a great get-shit-done system.

I’ve used a chainsaw, and you’re simultaneously amazed at how easily it slices through a tree, and that you’re dumb enough to use this thing three feet away from your vital organs.

This is unix.

Pipes are fantastic. Any two (well-written programs) can talk to each other in Unix.

All of the nastiness and difficulty of inter-process communication is solved with one character, | .

The stream is usually plaintext, the universal interface, but it doesn’t have to be.

With pipes, it doesn’t matter if your pipe is tab delimited, random email text, or some other random stuff.

Pipes are tremendous, beautiful, elegant component of the Unix chainsaw.

Named Pipes

A named pipe, also know as a FIFO (First In, First Out), is a special sort of file we can create with mkfifo.

$ mkfifo fqin

You’ll notice that is indeed a special type of file: p for pipe. You interface with these as if they were files with Unix redirection, not pipes, but they behave like pipes:

Even though the syntax is similar to shell redirection to a file, we’re not actually writing anything to our disk.

To remove the named pipe, we just use rm.

Creating and using two named pipes would prevent IO bottlenecks.

Tee

In computing , tee is a command using standard streams which reads standard input and writes in both standard output and one or more files, effectively duplicating its input.

It is primarily used in conjunction with pipes and filters.

The command is named after the T-splitter used in plumbing.

tee is normally used to split the output of a program so that it can be both displayed and saved in a file.

Process Substitution

Process substitution uses the same mechanism as named pipes, but does so without the need to actually create a lasting named pipe through claver shell syntax.

These are also appropriately called “anonymous named pipes”.

Process substitution is a form of interprocess communication that allows the input or output of a command to appear as a file.

The command is substituted in-line, where a file name would normally occur, by the command shell.

This allows programs that normally only accept files to directly read from or write to another program.

Process substitution advantages

The main advantages of process substitution over its alternatives are:

simplicity: the commands can be given inline there is no need to save temporary files or create named pipes first.
performance: Reading directly from another process is often faster than having to write a temporary file to disk, then read it back in. This also saves disk space.
parallelism: the substituted process can be running concurrently with the command reading its output or writing its input, taking advantage of multiprocessing to reduce the total time for the computation.

How system calls work

A system call is how a program requests a service from an operating system kernel.

System calls provide an essential interface between a process and the operating system.

System calls look like functions calls to programs using them, but in practice they are a bit more complicated than a function call, because they require a transaction from user mode to kernel mode.

Space Monoliths

Are advanced machines, three are discovered in the solar system by humans and it is revealed that thousands, if not more, were created throughout the solar system, although none are seen.

Lambda Complex

If anyone can handle this is the science team in the lambda complex! top secret teleportation labs, the core facility consist of four levels A, B, C, and D that fuel an extremely powerful interdimensional Portal located on level A

Lambda

Indicates the wavelength in a wavelength-division multiplexing optical communications system.

Denotes the failure rate of devices and systems in reliability theory, and it is measured in failure events per hour.

Numerically, this lambda is also the reciprocal of the mean time between failures.

In mathematical logic and computer science, lambda is used to introduce anonymous functions, expressed with the concepts of lambda calculus.

Chamber Computer Armor

A radio, tracking devices, and a heads-up display (HUD) which tracks health status and weapon ammunition usage, as well as including a weapons management system.

The suit contains an on-board computer system that constantly monitors the user's health and vital signs reacting to any changes in the user's condition with activation in the aforementioned apparatus, and something femerale-computer voice.

Welcome to the Chamber protective system, for use in hazardous environment conditions.
High impact reactive armour activated
Atmospheric contaminant sensors activated
vital sign monitoring activated
automatic medical systems engaged
defensive weapon selection system activated.
ammunition level monitoring activated
communication interface online
have a very safe day!

When the user obtains a battery, the suit will say:

Power # percent.
Power level is one hundred percent.

Systems

Systems should self-repair self-configure and evolve with time.

Efficiency and Clarity

To make something clearer add a layer of abstraction

To make something more efficient remove a layer of abstraction

In the last 30 years we have systematically chosen performance over clarity.

In the future processors will be so fast we can forget about efficiency, so all the mess in our legacy code will cause immense problems.

Write clear precise correct code.

Every ten years it will run 1000 times faster.

Names

Names are imprecise
Name imply a namespace
The named thing might change
Deciding a name is difficult
Unique names are difficult to make

Use hashes instead of names

hash://

Address cannot be spoofed, there is no address.
No problem choosing a name, there is no name.
Can be cached forever.
Content can be validated on arrival,
No subject to person-in-the-middle attacks.

Erlang functions

The functions do all their work internally, running in little processes that act like sandboxes and only talk with each other through message passing. (you can think of mail messages as an a good analogy)

Bus Messaging Pattern

The idea underlying “bus” messaging pattern is to provide the semantics similar to those of the hardware bus.

Everyone connected to the message bus gets any message sent to the bus.

Some words on state machines

A finite-state machine (FSM), or simply a state machine, is a mathematical model of computation used to design both computer programs and sequential logic circuits.

It is conceived as an abstract machine that can be in one of a finite number of states. The machine is in only one state at a time; the state it is in at any given time is called the current state.

It can change from one state to another when initiated by a triggering event or condition; this is called a transition. A particular FSM is defined by a list of its states, and the triggering condition for each transition.

Proxy

“The authority to act for another.”
In computer networks, a proxy server is a server that acts as an intermediary for requests from clients seeking resources from other servers.

Proxies were invented to add structure and encapsulation to distributed systems.

A proxy server that passes request and responses unmodified is usually called a gateway or sometimes a tunneling proxy.

Erlang Today

Language of choice for programming soft real time distributed applications.
Language of choice for multi core excluding GPU type stuff.
20 years battle tested experience with highly concurrent fault-tolerant systems with self-repair.
Great for rapid prototyping distributed programs.
Can manage few million devices from one Erlang machine.
Need DHT’s to scale to billions.

What robot workers needs

See what’s pending
Modify pending tasks in-place
Tags
See what workers are doing
See what workers have done
See failed tasks
Kill fat workers
Kill stale workers
Kill workers that are running too long
Keep leaded persistent workers
Distribute workers that run on multiple machines
Workers can watch multiple or all tags
Don’t release failed tasks

Seven deadly sins

Code even you cannot understand a week after you wrote it -no comments.
Code with no specifications.
Code that is shipped as soon as it runs and before it is beautiful.
Code with added features.
Code that is very very fast very very obscure and incorrect.
Code that is not beautiful
Code that you wrote without understanding the problem

Causality

A cause must always precede its effect
Information travels at or less that the speed of light
We do not know that something has happened until we get a message saying that the event has happened
We do not know how things are now at a remote location only how they were the last time we got a message from them.

Enterprise Search

The practice of making content from multiple enterprise-type sources, such as database and intranets, searchable to a defined audience.

Search your organization's existing pool of resources for answers your workers can use when responding to customers.

Fetch and retrieve many different types of web applications built outside the scope of the helpdesk.

Things like blogs forums, wikis or any web application where documentation is important to your organization.

Enterprise search systems index data and documents form a variety of sources such as: file systems, intranets, document management systems, e-mail, and databases. Many enterprise search systems integrate structured and unstructured data in their collections.

Solr

Open source enterprise search platform built on apache lucene.

Solr is highly reliable, scale and fault tolerant, providing, distributed indexing, replication and load-balance querying, automated failover recovery, centralized configuration and more.

Slrs is a standalone enterprise search server with a rest like api

yo put documents in ti indexing via json or binary over http toy query via http get and receive json or binary.

Riak Search

Allows for distributed, salable, fault tolerant, transparent, indexing and querying of riak values, after connecting bucket or bucket type to a Solr index toy simple write values such as JSON, plain text, riak data types, etc into riak as normal, and then query those indexes values using the Solr API.

Riak Search is more than a distributed search engine like SolrCloud or ElasticSearch because it’s directly integrated with Riak.

Riak Search is an integration of Solr for indexing and querying and Riak for Storage and distribution.

Keep in mind in order to properly store and later query for values.

schemas explain to solr how to index fields.
indexes are named solr indexes against which you will query
3. bucket index association signals to riak when to index values.

Speech recognition

# for most recent development in SR, see deep learning.

Speech recognition (SR) is the translation of spoken words into text. It is also known as automatic speech recognition (ASR), computer speech recognition, or just speech to text (STT).

Some systems use speaker-independent speech recognition while others use training where an individual speaker reads sections of text into SR systems. These systems analyze the person’s specific voice and use it to fine tune recognition of that person’s speech, resulting in more accurate transcriptions.

Systems that do not use training are called speaker-independent systems.

Systems that use training are called speaker-dependent systems.

Speech recognition applications include voice user interfaces such as voice dialling, call routing, home automation control, search, simple data entry, preparation of structured documents, speech-to-text processing, voice input control, aircraft direct voice input.

The term voice recognition refers to identifying the speaker, rather than what they are saying.

The current state of the art in speech recognition accuracy dominant since 2013 throughout the industry worldwide, is based on deep learning concepts, architectures, methodologies, algorithms, etc.

In control to the steady incremental improvements of the past few decades, the application of deep learning decreased word error rate by 30%.

Deep learning techniques have began to be used in language modeling as well.

both shallow form and deep form of artificial neural networks had been explored for many years during 80’s, 90’s and a few years into 2000.

But these methods never won over the non-uniform internal-handcrafting Gaussian mixture model / Hidden Markov model (GMM-HMM) technology based on generative models of speech trained discriminatively.

A number of key difficulties had been methodologically analyzed in 1990’s including gradient diminishing and weak temporal correlation structure in the neutral predictive models.

All these difficulties were in addition to the lack of big training data and big computing power in these early days.

Most SR researches who understood such barrier hence subsequently moved away from neural nets to pursue generative modeling approaches until the recent resurgence of deep learning that had overcome all these difficulties.

Models, methods, and algorithms

Both acoustic modeling and language models are important parts of modern statistically-based speech recognition algorithms. Hidden Markov Models (HMM’s) are widely used in many systems.

Language modeling is also used in many other natural language processing applications such as document classification or statistical machine translation.

Hidden Markov models

Modern general-purpose speech recognition systems are based on Hidden Markov Models.

These are statistical models that output a sequence of symbols or quantities. HMMs are used in speech recognition because a speech signal can be viewed as a piecewise stationary signal or a short-time stationary signal.

In a short time-scale (e.g 10 milliseconds) speech can be approximated as a stationary process.

Speech can be thought of as a Markov model for many stochastic purposes.

Another reason why HMM’s are popular is because they can be trained automatically and are simple and computationally feasible to use.

In speech recognition the hidden markov model would output a sequence of n-dimensional real-valued vectors (with n being a small integer such as 10), outputting one of these every 10 milliseconds.

The vectors would consist of cepstral coefficients, which are obtained by taking a Fourier transform of a short time window of speech and decorrelation the spectrum using a cosine transform, then taking the first (most significant) coefficients.

The hidden Markov model will tend to have in each state a statistical distribution that is a mixture of diagonal covariance Gaussians, which will give a likelihood for each observed vector.

Each word, or for more general speech recognition systems, each phoneme, will have a different output distribution; a hidden Markov model for a sequence of words or phonemes is made by concatenating the individual trained hidden Markov models for the separate words and phonemes.

Dynamic time warping (DTW)

Dynamic time warping is an approach that was historically used for speech recognition but has now largely been displaced by the more successful HMM-based approach.

Dynamic time warping is an algorithm for measuring similarity between two sequences that may vary in time or speed. For instance, similarities in walking patterns would be detected, even if in one video the person was walking slowly and if in another he or she were walking more quickly, or even if there were acceleration and decelerations during the course of one observation.

DTW has been applied to video, audio, and graphics - indeed, any data that can be turned into a linear representation can be analyzed with DTW.

A well-known application has been automatic speech recognition, to cope with different speaking speeds. In general it is a method that allows a computer to find a optimal match between two given sequences (e.g time series) with certain restrictions.

That is, the sequences are warped nonlinearly to match each other. This sequence alignment is often used in the context of hidden Markov models.

Neural networks

Deep neural networks emerged, as an attractive acoustic modeling approach in ASR in the late 1980’s. Since then, neural networks have been used in many aspects of speech recognition such as phoneme classification, isolated word recognition, and speaker adaptation.

In contrast to HMM’s, neural networks make no assumptions about feature statistical properties and have several qualities making them attractive recognition models for speech recognition.

When used to estimate the probabilisties of a speech feature segment, neural networls allow discriminative training in a natural and efficient manner.

Few assumptions on the statistics of input features are made with neural networks. However, in spite of their effectiveness in classifying short-time units, such as individual phones and isolated words, neural networks are rarely successful for continuous recofnition tasks, largely because of their lack of ability to model temporal dependencies.

However, recently Recurrent Neural Networks (RNN’s) and Time Delay Neural Networks (TDNN’s) have been used which have been shown to ber able to identify latent temporal dependencies and use this information to perform the task of speech recognition.

This however enormously increase the computational cost involved and hence makes the process of speech recofnition slower.

A lot of research is still going on this field to ensure that TDNN’s and RNN’s can be used in a more computationally affordable way to improve the speech recofnition accurace immensely.

Deep Neural Networks and Denoision Autoencoders are being experimented with to tackle this problem in an effective manner.

Due to the inability of tadition neural neryworks to model temporal dependencies, and alternative approach is to use naural networks as a pre-processing e,.g feature transformation, dimensionality reduction for the HMM based recognition.

Deep Neural Networks

A deep neural network (DNN) is an artificial neural network with multiple hidden layers of units between the input and output layers.

Similar to shallow neural networks, DNN’s can model complex nonlinear relationships.
DNN architectures generate compositional models, where extra layer enable composition of features from lower layers, giving a huge learning capacity and thus the potential of models complex patterns of speech data.

The DNN is the most popular type of deep learning achitectures succesfuly used as an ocoustic model for speech recognition since 2010.

Large output layers of the DNN based on context dependent HMM states constructed by decision trees were adopted.

One fundamental principle of deep learning is to do away with hand-crafted feature engineering and use raw features.

This principle was first exploted successfully in the architecture of deep autoencoder on the “raw” spectrogram or linear filter-bank features showing its superioltity over the mel-cepstral features which contrains a a few stages of fixed transformations from spectograms.

the true raw features of speech, waveforms, have more recentrly been shown to produce excelent larger-scale speech recogfnition results.

Since the initiall succesful debut of DNN’s for speech recofnition around 2009-2011, threre have been huge new progreeses made.

This progress as well as futrure directions has been summarized into the following eight major areas:

Scaling up/out and speedup DNN training and decoding.
Sequence discriminative training of DNNs
Feature processing by deep miodels with solid undestranding of the underlying mechanisms
Adaptation of DNN’s and related deep models
Multi-task and transfer learning by DNNs and related deep models.
Convolutional neural networks and how to design them to best exploit domain knowledge of speech
Recurrent neural network and its rich LSTM variants
Other types of deep models including tensor-based models and integrated deep generative / discriminative models.

Large-scale automatic speech recognition (ASR) is the first and most convincing succesful case of deep learning in recent history, embraced by both industry and acdamic across the board.

All major commercial speech recognition systems nowadays are based on deep learning methods.

Computer Assistant

Software do now and do likewise.

Ai robo monkeys.

Old man quote.

If every tool, when ordered, or even of its own accord, could do the work that benefits it, then there would be no need either of apprentices for the master workers or slaves for the lords.
Aristotle.

The intelligent personal assistant has its origins from a military-funded artificial intelligence project called CALO, for “cognitive assistant that leans and organizes”.
Organize and Maintain Information

On the key aspects of an intelligent personal assistant is its ability to organize and maintain information. This includes the management of information. 

Including the management of emails, calendar, events, files, to-go-lists, etc

Cognitive assistant that learns and organizes.

Setup meetings with friends, partners, coworkers, and clients, across organizations, calendaring programs, and scheduling platforms.

I/O FUN provides you with a dedicated army of monkeys, available to help you setup meetings.

That’s all the service does, run errands, make phone calls, deliver messages.

Betty is persistent, and speaks and understands conversational English -- there’s no need to write your emails in specific format or provide data in computer-speak.

betty@iofun.io, simon@iofun.io

Simon and Betty.

Chambers
hello and, again welcome to the I/O FUN computer-aided center.
We hope your brief visit in this chamber has been a pleasant one.
Your account has been processed and we are now ready to begin the test.
Before we start, however, keep in mind that although fun and learning are primary goals of all center activities, serious crashes may occur.
For your own safety and the safety of others, please refrain from, ___________.
Please refrain from failing many thanks, to fail thanks.
Por favor bordon de fallar muchas gracias de fallar gracias.
Stand back. The teleport will open in three, two, one.
Excellent. Please proceed into the chamber lock after completing each test.
First, however, note the incandescent particle field across the exit.
This grill will vaporize any unauthorized equipment that pass through it, for instance, the storage cube.
Please do not attempt to remove testing tools for the testing area.
A replacement storage cube will be delivered shortly.
Please do not attempt to remove testing tools from the testing area,
A replacement storage cube will be delivered shortly.
Please place the storage cube on the button.
Perfect, please move quickly to the chamber lock, as the effects of prolonged exposure to the button are not part of this test.
You’re doing very well!
Very good! You are now in possession of the stuff that builds things on tremulous.
With it, you can create your own resources.
These intra-dimensional resource gates have proven to be completely safe.
The Device, however, has not.
Do not touch the operational end of the device.
Do not touch directly at the operational end of the device.
Do not submerge the device in liquid, even partially.
Most importantly, under no circumstances should you (......).
Please proceed to the chamerlock. Mind the gap.
Welcome to test chamber four.
You’re doing quite well.
Once again, excellent work.
As part of a required test protocol, we will not monitor the next test chamber.
You will entirely on your own. Good Luck.
As part of a required test protocol, our previous statement suggesting that we would not monitor this chamber was an outright fabrication.
Good task! As part of a required test protocol, we will stop enhancing the truth in three, two, …
The Device has been modified so that it can now menufacture linked resources at one.


Chamber

Pilot support and development interface system chamber.

Instant predictions
Only when computer is fast enough.
Always show instant results.
Never show instant results.

Results per page
10, 20, 30, 40, 50, 100

I/O FUN predictions shows 10 results.

Spoken answers

When search by voice, should we speak the answers aloud.

Speak answers for voice search only with headsets else do text.

Just show text.

Search history
When signed in, you can receive more relevant results and recommendations based on your search activity.

You can turn off or edit your search history at any time.
Inventor’s paradox
The inventor’s paradox is a phenomenon that occurs in seeking a solution to a given problem.

Instead of solving a specific type of problem which would seem intuitively easier, it can be easier to solve a more general, which mathematics, programming, and logic, as well as other areas that involve critical thinking.

The more ambitious plan may have more chances of succes .. provided it is not based on a more pretension but on some vision of the things beyong those immediately present.

Goarge Polya. How to Solve It.

Or in other words, to solve what you desire, you may have to solve more than what you actually want to in order to get a propertly working flow of information.

There lies the inventors paradox, that it is often significantly easier to find a general solution than a morespecific one, which may naturally have a simpler algorithm and cleaner design, and typically can take less time to solve in comparision with a particular problem.

Unix sockets
Have been used in thousands of applicatins over the years, but they suffer from some limitations.

Alternatives exist in the form of various “I/O frameworks” and enterprise messaging systems but both of these approaches have their own set of drawbacks.

ZeroMQ
Zero-Em-Queue is a messaging system that tackles these issues by taking a different approach.

Instead of inventing new API’s and complex wire protocols, 0MQ extends the socket API, eliminating the learning curve and allowing network programmer to master it in a soft learning curve.

The wire protocols are simplistic, even trivial.

Performance matches and often exceeds that of raw sockets.

Monitoring tool
Web based tool for monitoring and administering clusters.

Real-time monitoring using event messages
Task progress and history
Ability to show task details, arguments, start time, runtime, …
Graphs and statistics
Remote control
view worker status and statistics
shutdown and restart worker instances
control worker pool size and autoscale settings
view and modify the queues a worker instance consumes from
view concurrently running coroutines
view schedules tasks ETA countdown
view reserved and revoked tasks
apply time and rate limits
configuration viewer
revoke or terminate tasks

What makes a cluster a cluster?
With the ever-growing field of distributed systems technologies, it is helpful to compare the goals, roles and differences of some of these new projects based on their functionality.
A key aspect of the separation of concerns with well-defined responsibilities and dependence between components:

Every layer depends on the layer below it and provides useful network functionality connection, retry, packetization to the layer above it.

At the top, finally are web sessions and applications of all sorts running and abstracting communication.

The world rest on a turtle, that rest on a turtle, that rest on a turtle, … that … u get the idea.

Applications, containers, orchestration and scheduling, cluster resources, cluster consensus, os/execution, hardware.

Duckduckgo Instant Answer API
Free access to instant answers like:

topic summaries, categories, disambiguation, and ibang redirects.

Long-term goal is for all of the instant answers to be available through this open API.

Many of these instant answers are open source via DuckDUckHack.

Using that platform, you can add your own APIs and data sources as well.

Instant answers come from a variety of sources, including Wikipedia, Wikia, CruchBase, Github, WikiHow, The Free Dictionary - over 100 in total.

It offer variety of uses, e.g:

Defining people, places, things, words, and concepts, e.g for side-bards, onMouseover or onhighlight.

Providing direct links to other services via !bang syntax.

Listing related topics.

Giving official sites when available.

Query URL in the API subdomaing, e.g http://fun.codemachine.io/?q=IOFUN&format=json

Reinforcement Learning
An area of machine learning inspired by behaviorist psychology, concerned with how software agents ought to make actions in an environment so as to maximize some notion of cumulative reward.

In economics and game theory, reinforcement learning may be used to explain how equilibrium may arise under bounded rationality.

In machine learning, the environment is typically formulated as a Markov decision process (MDP) as many reinforcement learning algorithms for this context utilize dynamic programming techniques.

There is a focus on on-line performance, which involves funding a balance between exploration and concurrent knowledge.

The exploration us explositation trade-off in reinformcement earnig has been most thoroughly studied though the multi-armed bandit problem and in finite MDPs.

Client-server
A software achitecture model consisting of two parts, client systems and server systems both communicate over a computer network or on the same computer.

A client-server application is a distributed system consisting of both client and server software.

The client process always initiates a connection to the server. while the server process always waits for requests from any client.

When both the client process and server process are runnign on the same computer, this is called a single seat setup.

Another type of related software architecture know as peer-to-peer architectures are often abbreviated using the acronym P2P.

The client-server relationship describes the relation between the client and how it makes a service request to the server, and how the server can accept these requests, process them, and return the requested information to the client.

Revisiting 0MQ
Around early 2015, a few core ZeroMQ maintainers decided to experiment with a simpler messaging API, and decided it’d be profitable to explore rethinking multipart messages from ZeroMQ.
Don’t Panic
The existing multipart functionality is defined by ZeroMQ RFC 23 ZMTP and 28 the request-reply pattern.

There is no plan to stop supporting these RFC, nor to remove the multipart API contracts.

The strategy for shifting functionality is to develop new contracts over time, and when these are stable and proven, deprecate old ones.

This happens over many years, with new code existing in parallel to old code.

So the focus of this experiment are mainly in new code: new language binding, new protocols, and new stacks.

The overall goal, as I’ll explain, is to make things simpler, and easier to understand.

What’s the Problem
Multipart messages aim to solve a number of problems, and in turn create a number of problems.

At the core of our shift is the understanding that the cost now appear to outweigh the benefits.

It is confusing, as a “message” means both a part, and a list of parts.

We’ve had to add new terms like “frame” to compensate.


The multipart request-reply envelope is complex to understand, and yet any realistic application has to use it.

This creates a real learning cost.


ZeroMQ servers exploit the request-reply envelope to do server/client routing using ROUTER sockets.

This always confuses new users.


ZeroMQ implementations cannot realistically make sockets thread-safe, as they must serialize multiple send and recv calls to a single thread.

Thus, multipart messages have stopped us making threadsafe sockets.


Multipart messages are counter-intuitive the send method does not actually send anything, it queues the message until the final part is sent.

New users often try to use multipart to send large files.

This does not work.


The two main sockets that exploit the multipart mechanism REQ and REP cannot recover from failures, and rarely used by real applications.


Supporting multipart messages has raised complexity and performance in all bindings and tools.

It is significantly harder, and more work to support and list of messages than to support a single frame.


Multipart data is incompatible with other layers that treat data as stream of bytes or blobs.


The Identity
The ZMQ_IDENTITY socket setting is one fo the more confused, and in my view dangerous semantics in ZMQ.

It allows a DEALER, REQ, REP peer to tell a ROUTER socket what value to use for its internal routing ID.

“User-defined identities” arrive as a magical first frame that can be up to 255 bytes long.

It was a mistake to mix node identities with routing information.

These are two separate layers (contracts) and mixing them creates a confused hybrid contract.

What happens when two clients connect with the same identity?

At what stage is the identity checked?

How do we correlate suck identities with application-level identities?

How do we proxying traffic?

It has been clear for some time that:

We should stop using the term “Identity” for server-side routing information which is essentially the handle of a pipe.


We should delegate identity management, authentication and access control to higher layers, where different decisions can be made depending on the case.


We should in fact hide the routing information in simple request-reply servers.
A Better Framing Approach
The ZeroMQ community has developed its own tool for framing, namely zproto.

This generates a fast binary codec for a protocol, in arbitrary languages.

The advantage of zproto over framing is that you get a properly documented protocol with robust error checking at client and server side.

A Better Client-Server Pattern
While the standard pattern for client-server cases is DEALER-ROUTER, these sockets are clumsy and often confusing to newcomers.

The names are unclear.

The ROUTER socket uses multipart messages for routing, which is semantically and technically confusing.

There is a much simpler, more obvious client-server pattern:


CLIENT and SERVER socket types that are separate from the request-reply pattern.


CLIENT can implement, immediately necessary logic for heartbeating, and recovery from server restarts.


SERVER can implement client sessions, recovery from network failures, and disconnection of idle clients.

There are several possibilities for a SERVER socket design.


Just like ROUTER today, except the routing information is not provided as a multipart frame. Instead it is a message property, it cannot be a socket property, if sockets are to be thread-safe.


A higher level socket, that automatically manages client-sessions.

This means, identifying new connections and reconnections, when the same client reconnects on a different network socket, respoing to a heartbeats, and expiring idle clients.

Similarly, CLIENT could be very similar to DEALER, or something more sophisticated that deals with the requirements we always have in client-server scenarios.

Heartbeating and Sessions
Looking at several years of building client-server stacks with 0MQ, a consistent pattern emerges for reliable session management.

We Build this today using DEALER ROUTER and zproto for protocol commands.
It could profitably be built into the CLIENT-SERVER sockets, and the ZMTP protocol:

The server must detect new client sessions. Ideally, a session identifies a CLIENT socket instance, with the same lifecycle.

Today we use the routing ID, which means we cannot recover a client session after a network break.


The client must send heartbeats, when idle.

The heartbeat interval is typically one or several seconds, depending on client-side power considerations.

A heartbeat command PING carries no data.


The server must respond to heartbeats, simple by sending a heartbeat reply (PING-OK), again carrying no data.


Clients must send at most a few pings, if they are not getting PING-OK replies.

Otherwise they will fill up their outgoing pipes with a thousand PING commands.


Servers must expire clients that have send nothing within a certain timeout typically 10 to 30 seconds, depending on the network.


For session management, the client must send a unique ID (UUID) that can be used as session ID.

Today we use the routing ID for this.

Neither are ideal. The best solution is that a CLIENT socket automatically generate its own unique session ID, which cannot be over-ridden or used at any layer except this one.

The client send its session ID when connection the the server, The server holds known client session in a storage.

If the client connects with an existing session ID, the server attaches that new connection to the existing session.

If not, it creates a new session.

Sessions expire when they have no active for 10-30 seconds (per heartbeating).
This session reconnection is invisible to the application. It sees, at worst, a brief lull in traffic, wich then resumes.

Conclusions
It’s unclear we can make these shifts succesfully. However, if we can, then here are some potential outcomes:

The REQ-REP-DEALER-ROUTER socket types will disapper (be deprecated).


The ZMQ_IDENTITY concept will disappear.


New CLIENT and SERVER sockets will replace REQ-REP-DEALER-ROUTER.


Messages will be single opaque blobs of data.


All other names for messages frames and parts will be deprecated.


All “recv more” and “send more” semantics will be deprecated.


CLIENTs and SERVERs may eventually do heartbeating and session management automatically.


All socket types that no longer accept multipart messages can probably be made thread-safe.
Semantic Versioning 2.0.0
Summary
Given a version number, MAJOR, MINOR, PATCH increment the:

MAJOR version when you make incompatible API changes.
MINOR version when you add functionality in a backwards-compatible manner.
PATCH version when you make backwards-compatible bug fixes.

semver.org

Automatic Scaling
You don’t need to configure your resource needs.
One CPU can handle many requests per second.
Apps are DHT really mapped onto CPU’s:
- One process per app, many apps per CPU
- Creating a new process is a matter of cloning a generic model process, pattern and then loading the app code.
- Clones are pre-created and sit in a queue.
- Process hangs around to handle more requests (Reuse)
- Eventually old processes are killed (recycle)
Bussy apps get assigned to multiple CPUs:
- This is automatically adapts to the need as long as CPUs are available.

Count von Count
Often know simple as “The Count” is one of the Mupper characters on sesame street.

The Count is a vampire educated in simple mathematical concepts, most notably counting.


Token
In general, a token is a object that represents something else, such as another object (either physical or virtual), or an obstract concept as, in computers, there are a number of types of tokens.

Session ID
A session identifier, session ID, or session token is a piece of data that is used in network communications to identify a session.

A session ID typically granted to a visitor or his first visit to a site. It is different from a user ID in that sessions are typically short-lived and may become invalid after a certain goal has been met.

A session token is a unique identifier, usually in the form, of a hash generated by a hash function that is generated and sent from a server to a client to identify the current interaction session.

Clients usually stores and sends the token as an HTTP cookie or as a parameter in HTTP queries.

Access token
In computer systems, an access token contains the security credentials for a login session and identifies the user, the user’s groups, the user’s privileges, and in some cases, a particular application.

A token is used to make security decisions and to store tamper-proof information about some system entity.

While a token is generally used to represent only security information, it is capable of holding additional free-form data that can be attached while the token is being created.

Security token
May be a physical device that an authorized user of computer services is given to ease authentication.

The term may also refer to software tokens.

Security tokens are used to prove one's identity electronically.

The token is used in addition to or in pace of a password to prove that the customer is who they claim to be.

The token acts like an electronic key to access something.

Inconsistency Robust Reasoning
Large scale information systems are chock full of inconsistencies
Can’t get rid of them

Islet
Islets exponentially faster than Parallel Lambda Calculus.
Distributed
Intermittently connected
Pervasive inconsistencies

Inconsistency Robustness
In information system performance in the face of continually pervasive inconsistencies.

A shift from the previously dominant paradigms of inconsistency denial and inconsistency elimination attempting to sweep them under the rug.

Inconsistency robustness in both an observed phenomenon and a desired feature.

It is a observed phenomenon because large information systems are required to operated in a environment of pervasive inconsistency. How are they doing?

It is a desired feature because we need to improve the performance of large information systems.

Need to Tune Strategy for achieving a goal
Need statistics of large info!

How often is there a morbidity that is associated with both symptoms?
How often is this morbidity a common cause of the symptoms?

Computation machine thinking reducible to
Message sending
Message receiving
Message receiver creation
Message processing including how to process future messages.

Stuffs
Technology change mandates review:
No principled way to distinguish computation from human thinking.

Router
A networking device that forwards data packets between computer networks.
A router is connected to two or more data lines from different networks, as opposed to a network switch, which connects data lines from one single network.

When a data packet comes in on one of the lines, the router reads the address information in the packet to determine its ultimate destination.

Then, using information in its routing table or routing policy, it directs the packet to the next network on its journey.

This creates an overlay internetwork.

Routers perform the “traffic directing” functions on the internet.

A data packet is typically forwarded from one router to another through the networks that constitute the internetwork until it reaches its destination node.

Core routers forward data at high speed along the optical fiber lines of the internet backbone.

Through routers are typically dedicated hardware devices, use of software-based routers has grown increasingly common.

Router Applications
When multiple routers are used in interconnected networks, the routers exchange information about destination addresses using a dynamic routing protocol.

Each router builds up a table listing the preferred routes between any two systems on the interconnected networks.

Routers may also be used to connect two or more logical groups of computer devices known as subnets, each with a different sub-network address.

The subnet addresses record in the router do not necessarily map directly to the physical interface connections.

Internet connectivity
Routers intended for ISP and major enterprise connectivity usually exchange routing information using Border Gateway Protocol (BGP) RFC 4098.

Voice, Data, Fax, Video processing routers:
Commonly referred to as access servers or gateways, these devices are used to route and process voice, data, video, and fax traffic on the interwebz.

Historical and Technical information
The very first device that had fundamentally the same functionality as a router does today, was the Interface Message Processor (IMP) IMP’s were the devices that made up the ARPANET, the first packet networks.

The idea for a router called “gateways” at the time.

Fifth generation computer
The Fifth generation computer systems project FGCS was an initiative by Japan’s Minister of International Trade and Industry, begun in 1982, to create a computer using massively parallel computing processing.

It was to be the result of a massive government / industry research project in Japan during the 1980’s.

It aimed to create an “epoch-making computer” with-supercomputer-like performance and to provide a platform for future developments in artificial intelligence.

Development of computer systems which will be applicable to knowledge information processing systems.

Kronos
1985 Russian fifh generation computer project START, in which Kronos became a platform for developing multiprocessor reconfigurable systems MARS.

Ceres
The largest object in the asteroid belt, which lies between the orbits of Mars and Jupiter.

Machine
Lets you create hosts on your computer, on cloud providers, and inside your own data center. It create servers, installs Salt on them, then configures the Machine client to talk to them.

Once your Machine host has been created, it then has a number of commands for managing them:

Starting, stopping, restarting
Upgrading
Configuring the machine client to talk to your host

Swarm
Is a native clustering for machine.

It turns a pool of Machine hosts into a single virtual host.

Swarm servers the standard I/O FUN resources, so any tool which already communicates with a I/O FUN System daemon can use Swarm to transparently scale to multiple hosts: [...]
 and, of course, the I/O FUN client itself. (IMP’s??)

The goal is to provide a smooth out-of-box experience for simple use cases, and allow swapping backends.

XHR
The XML HTTP Request (XHR) object, the main tool used by Ajax applications for browser-server communication.

For the most part, XMLHttpRequest long polling works like any standard use of XHR.

The browser makes an asynchronous request of ther server, which may wait for data to be available before responding.

The response con contain ancoded data typically JSON, MessagePkg or JavaScript to be executed by the client.

At the end of the processing of the response the browser creates and sends another XHR to await the next event.

Thus the browser always keeps a request outstanding with the server, to be answered as each event occurs.

Push Technology
Push, or server push, describes a style of internet-based communication where the request for a given transaction is initiated by the publisher or central server.

It is contrasted with pull/get, where the request for the transmission of information is initiated by the receiver or client.

Push services are often based on information preferences expressed in advance. This is called a publish/subscribe model.

A client “subscribes” to various information “channels” provided by a server; whenever new content is available on one of those channels, the server pushes that information out to the client.

Client-Server
A distributed computing structure that partitions tasks or workloads between the providers of a resource or service called servers, and service requesters, called clients.

Servers are classified by the services they provide.

In general, a service is an abstraction of computer resources and a client does not have to be concerned with how the server performs while fulfilling the request and delivering the response.

The client only has to understand the response based on the well-known application protocol, i.e: 

The content and the formatting of the data for the requested service.

Clients Servers and Messages
Clients and servers exchange messages in a request-response messaging pattern:

The client sends a request, and the server returns a response.

This exchange of messages is an example of inter-process communication.

To communicate, the computers must follow rules that both the client and the server know what to expect.

The rules of communication are defined in a communications protocol.

All client-server protocols operate in the application layer.

Privacy-Friendly Client Cloud Forest Computing

The world rest in a turtle, that rest in another turtle… etc, cloud analogy the same up to a cloud to a cloud, up to another cloud.

The key is on the client. Like the one you have in your pocket.

ORGs Paradigm
Organizations of Restricted Generality

ORGs are computer organizations but people are integral to their operation.
ORGs operate according principles and methods of human organizations.

- Authority

- Accountability


ORGs are distributed across systems
Semantic integration
Inconsistency


Message Composability
Interaction using messages
Differs from global state composability (transactional memory)

Global Assignment
Considered Harmful
An encrypted message
Public key
Private key

Need coordination, responsiveness, reliability to work even communication with datacenters is cut off.

MUST be profitable.

Cyber stuff coordination

Massive concurrency required to provide interactive responsiveness.

Nodes
A node is the unit of scheduling in I/O FUN.

It is a resource envelope in which one or more containers run.

Containers that are part of the same node are guaranteed to be scheduled together onto the same machine, and can share stare via message passing.

Nodes provide an environment similar to running multiple processes in a single VM.

Users can deploy multiple co-located, cooperative processes in an ode without having to give up simplicity.

Resources
Although primary role is to manage the lifecycles of tasks and machines, the applications that run on benefit from many other cluster services, including names and load balancing.

A resource has a name and maps to a dynamic set of nodes defined by a label selector.

Any container in the cluster can connect to the resource using the resource name.

Automatic load-balances connections to resources among the nodes that match the label selector, and keeps track of where the nodes are running as they get rescheduled over time due to failures.

Tags and Labels
A container is usually one replica in a collection of identical or nearly identical containers that correspond to one tier of an Internet resource.

Organize nodes using labels, which are arbitrary key/value pairs that users attach to nodes and in fact to any object in the system.

Selling services
The financial return of cost on open-source software can also come from selling services, such as training, technical support, or consulting, rather than the software itself.

Offering open-source software in source code from only, while providing executable binaries to paying customers only, offering the commercial service of compiling and packaging of the software.

Selling of brander merchandise
Some open-source organizations sell branded merchandise articles like t-shirts and coffee mugs.

This can be also seen as an additional service provided to the user community.

Selling software as a Service
Selling subscriptions for online accounts and server access to customer as a way of making profit based on open-source software.

Combining desktop software with a service, called software plus services.

Operations support systems
Or operational support systems, are computer systems used by communications service providers to manage their networks.

They support management functions such as network inventory, service provisioning, network configuration and fault management.

Together with business support systems they are used to support various end-to-end telecommunication services.

The two systems together are often abbreviated by simple B/OSS.

Automation
It became obvious that much of this activity could be replaced by computers.

In the next 5 years or so, the cloud companies created a number of computer systems which automated much of this activity.

This was one of the driving factors for the development of Unix and C.

Architecture
A lot of work on oSS has been centered on defining its architecture. Put simply there are key elements of OSS:

Processes, the sequence of events.
Data, the information that is acted upon.
Applications.

A Web Service Again
A web service is a method of communication between two electronic devices over a network.

It is a software function provided at a network address over the Web with the service always on as in the concept of utility computing.

CONCEAL
Prevent from being seen or discovered.

Hold back; keep from being perceived by others.

Synonyms: hide, hold in, hold back.

Radio noise network sisters on heartbeats.
Heartbeat monitor listens to server heartbeat
Heartbeat generator on client sends heartbeats
Simple state machine for task execution
One process per connected client 
Incoming message validation and decode
Outgoing message signing
Tracks heartbeats from client
Tracts state of client, if state deviates from where it should be, we reset the client.

Unix style
When Unix and C were developed, they were designed by people who had already experienced first hand the evils of big software, or monolithic systems comprised of hundreds of thousands of lines of code without attention paid to modularity, that had often swelled to the point where no one understood the whole system.

The idea behind the Unix environment, as a reaction to this, was to encourage people to write small programs and build larger systems using simple communication structures like pipes and files.

The idea behind both is to write small programs, functional “building blocks” that are easy to reason about, and build more complex systems out of them while retaining the ability to piecewise debug simple components in event of failure.

I adhere to this small-program mentality.

I’m not saying “don’t be ambitious”.

Be ambitious, but build large systems while keeping individual modules small.

If a file is too big to read in one sitting break it up.

Constructivism
Constructivism is a view in philosophy according to which all “knowledge” is a compilation of human-made constructions not the neutral discovery of an objective truth.

Whereas objectivism is concerned with the “object of our knowledge”, constructivism emphasises “how we construct knowledge”.

Constructivism proposes new definitions for knowledge and truth that form a new paradigm, based on inter-subjectivity instead of the classical objectivity, and on viability instead of truth.

Piagetian constructivism, however, believes in objectivity-constructs can be validated through experimentation.

The constructivist point of view is pragmatic.

Capability
The quality of being capable.

An aptitude that may be developed.

Autodidactism
Or self-education is the act of self-directed learning about a subject or subjects in which one has had little to no formal education.

Successful self-teaching requires self-discipline and reflective capability.

Constructionism
learning is inspired by the constructivist theory that individual learners construct mental models to understand the word around them.

Constructivism advocates student-centered, discovery learning where students use information they already know to acquire more knowledge.

Students learn through participation in project-based learning where they make connections between different ideas and areas of knowledge facilitated through coaching rather than using lecture or step-by-step guidance.

Further, constructionism holds that learning can happen most effectively when people are active in making tangible objects in the real world.

Some have tried to describe constructionism as a “learning-by-making” formula but it should be considered much richer in its implications that could be conveyed by any such formula.

Logistics
The discipline of planning and carrying out the movement and maintenance of military forces. In its most comprehensive sense, it is those aspects or military operations that deal with:


Design, development, acquisition, storage, distribution, maintenance, evacuation, and disposition of material.
Transport of personnel.
Acquisition or construction, maintenance, operation, and disposition of facilities.
Acquisition or furnishing of services.
Medical and health service support.

The word logistics is derived from the Greek adjective logistikos meaning skilled in calculating.

The first administrative use of the word was in Roman times when there was a military administrative official with the title Logista.

At that time, the word apparently implied skill involved in numerical computations.

Systems should
Self-repair, self-configure and evolve with time.

Fail Fast
The process approach to fault isolation advocates that the process software be fail-fast, it should either function correctly or it should detect the fault, signal failure and stop operating.

Processes are made fail-fast by defensive programming. (WTF?)

They check all their inputs, intermediate results and data structures as a matter of course.

If any error is detected, they signal a failure and stop. In the terminology of Christians, fail-fast software has small fault detection, error latency.

Jim Gray.

Fail early
A fault in a software system can cause one or more errors. The latency time which is the interval between the existence of the fault and the occurrence of the error can be very high, which complicates the backwards analysis of an error.

For an effective error handling we must detect errors and failures as early as possible.
Renzel

Halt on failure
In the event of an error a processor should halt instead of performing a possible erroneous operation.

Failure status property when a processor fails, other processors in the system must be informed. The reason for failure must be communicated.

Stable Storage Property the storage of a processor should be partitioned into stable storage which survives a processor crash and volatile storage which is lost if a processor crashes.

Schneider

The laws of thought are inconsistent!
Our information systems are full of inconsistencies.
Nevertheless. We want semantics and so use paraconsistent logic (WTF?)

Paradigm Shift
Consistency Maintenance to Rapid Recovery.

Semantic Integration
Requirements
Intuitive semantic user interface
Scalable semantic engine

Laws of logic revised to tolerate inconsistency
Lesson learned

Humility:
We don’t know much
Some of it is wrong
But we don’t know which parts!

Progress not Perfection
Concurrency, Information, Humans, Acceleration, Semantic Enhancement, Client-Server model, semantic integration, Client Cloud Cube.

libevent
A software library that provides asynchronous event notifications.

The API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached.

libevent also support callbacks triggered by signals and regular timeouts.

Notable applications:


Google Chrome
Memcached
Transmission
Tor
ntpd

Unix signal
This is about POSIX-style signals.

Signals are a limited form of interprocess communication used in Unix, Unix-like and other POSIX-compliant operating systems.

A signal is an asynchronous notification send to a process or to a specific thread within the same process in order to notify it of an event that occurred.

When a signal is sent , the operating system interrupts the target process’s normal flow of execution to deliver the signal.

Execution can be interrupted during any non-atomic instruction. If the process has previously registered a signal handler, that routine is executed.

Otherwise, the default signal handler is executed.

inode
In Unix-style file system, an index node, informally referred to as an inode, is a data structure used to represent a filesystem object, which can be one of various things.

Including a file or a directory.

Each inode stores the attributes and disk block locations of the filesystem object’s data.

Filesystem object attributes may include manipulation metadata (e.g change, access, modification and creation times) as well as normally identifying the listed object by referring to its inode.

The directory contains an entry for itself, its parent, and each of its children.

inotify
(inode notify) is a Linux kernel subsystem that acts to extend filesystems to notice changes to the filesystem, and report those changes to applications.

It replaces an earlier facility, dnotify, which had similar goals.

Its functionality permits reindexing of changed files without scanning the filesystem for changes every few minutes, which would be very inefficient.

By being told directly by the kernel that a file has changed indexing utilities can achieve change-ro-reindexing times of only about a second.

Inotify cas also be used to automatically update directory, views, reload configuration files, log changes, backup, synchronize, and upload.

Clutch
A clutch of eggs refers to all the eggs produced by birds, amphibians, or reptiles, often at a single time, particularly those laid in a nest.

The technique double-clutching is used to dible the production of a species eggs.

The act of putting one’s hand in a nest to remove eggs is known as “dipping the clutch”.

Omen
An omen also called presage is a phenomenon that is believed to foretell the future, often signifying the advent of change.

People lie with a divine message from their goals.

Through the word “omen” is usually devoid of reference to the change’s nature hence being possibly either “good” or “bad”, the term is more often used in a foreboding sense, as with the word “ominous” the origin of the word is unknown although it may be connected with the Latin word audire, meaning “to hear”.

Node (networking)
In communication networks, a node Latin nodus ‘knot’ is either a connection point, a redistribution point or a communication endpoint.

The definition of a node depends, on the network and protocol layer referred to.

Distribution system nodes
If the network in question is a distributed system, the nodes are clients, servers, or peers.

A peer may sometimes serve as client, sometimes server.

In a peer-to-peer or overlay network, nodes that activate route data for the other networked devices as well as themselves are called supernodes.

Construction and management simulation
A type of simulation game in which players build, expand, or manage fictional communities or projects and campaigns with limited resources.

The player goal is not to defeat an enemy, but to build something within the context of an ongoing process.

Games in this category are sometimes also called “management games”.

Players usually have two types of tools at their disposal: tools for building and tools for managing.

Goals

Free-form construction mode where players can build up as they see fit, which appeals to a player’s sense of creativity and desire for control.

As with life we have no victory condition, although players can always lose by bankrupting themselves of resources.

The goal emphasize growth, and the player must successfully manage their economy in order to construct larger creations and gain further creative power.

Interface

Because the player must manage a complex internal economy construction and management make use of a web interface.

Players are given computer-like controls such as pull-down menus and buttons.

Players may also understand the game economy through graphs and other analytic tools.

This includes advisers that warn players of problems and describe current needs.

Multiprocessing
Process-based interface.

Multiprocessing is a package that supports spawning processes using an API similar to the threading module.

The module offers both local and remote concurrency, effectively side-stepping the GIL by using subprocesses instead of threads.

The Pool object which offers a convenient means of parallelizing the execution of a function across multiple input values, distributing the input data across processes (Data Parallelism).

Romero
Get, Yes, No, Come, Stay, Action, Attack, Hold back.

The uses fundamental that is use for the movement of all the monsters and obey system but they all had their own special code to do ambient movements and make decisions on that they should do based on what you’re doing.

And also you give-them commands, tasks and orders.

Keep it Simple
Start with gen_server and supervisor
See if they are good enough
Go custom otherwise
Make it work, make it pretty, make it fast.

When the abstraction is inappropriate you should ditch the gen_server and roll your own.

Joe

Principate
27 BC - 284 AD

Is the first period of the Roman Empire extending from the beginning of the reign of Augustus Caesar to the Crisis of the Third Century.

The principate is characterized by a concerted effort on the part of the emperors to preserve the illusion of the formal continuance of the Roman Republic.

It is etymologically derived from the Latin word princeps, meaning chief or first, the political regime dominated by such a political leader, whether or not he is formally head of state and/or head of government.

This reflects the principate emperors assertion that they were merely first among equals among the citizens of Mars.

Emperors tended not to flaunt their power and usually respected the rights of citizens.

The title, in full, princeps senatus I princeps civitatis, first amongst the senators first amongst the citizens, was first adopted by Octavian Caesar Augustus, 27 BC - AD 14, the first Roman emperor, who choose like the assassinated dictator Julius Caesar not to reintroduce a legal monarchy.

Constitution of the Martian Empire.
An unwritten set of guidelines and principles passed down mainly through precedent.

After the fall of the Republic, the constitutional balance of power shifted from the Senate to the Emperor.

Beginning with the first emperor, Augustus, the emperor and the senate were technically two co-equal branches of government.

In practice, however the actual authority of the imperial senate was negligible, as the emperor held the true power of the state.

Competitive learning
A form of unsupervised learning in artificial neural networks, in which nodes compete for the right to respond to a subset of the input data.

A variant of Hebbian learning, competitive learning works by increasing the specialization of each node in the network.

It is well suited to find clusters within data.

Models and algorithms based on the principle of competitive learning include vector quantization and self-organizing maps (kohonen maps)

Trajan’s Column

Is a Roman triumphal column in Rome, that commemorates Roman emperor Trajan’s victory in Dacian Wars.

It was probably constructed under the supervision of the architect Apollodorus of Damascus at the order of the Roman Senate.

It is located in Trajan’s Forum, built near the Quirinal Hill, north of the Roman Forum.

Completed in AD 113, the freestanding column is most famous for its spiral base relief, which artistically describes the epic wars between the Romans and Dacians. 101-102 and 105-106.

Overlords
Overlords provide control for your cubes, legions, minions, workers, imps, units, monkeys, daemons.

As your forces grow in number, you must spawn more overlords to control them.

The overlord provides control, detection and transportation once upgraded.

This is our supervisor analogy.

Nonpreemptive multitasking
A style of computer multitasking in which the operating system never initiates a context switch from a running process to another process.

Such systems are either statically scheduled most often periodic systems or exhibit some form of cooperative multitasking, in which case the computational tasks can self interrupt and voluntary give control to other tasks.

When non preemptive is used, a process that receives such resources can not be interrupted until it is finished.

Cooperative multitasking is a type of multitasking in which the process currently controlling the CPU must offer control to other processes.

It is called “cooperative” because all programs must cooperate for it to work.

In contrast, preemptive multitasking interrupts applications and give control to other processes outside of an application’s control.

ORGs
Based on Marian Reforms, Electronic + Humans COLLABORATION.

Incompleteness means Inconsistency
Let us suppose I prove the unprovability in Russell’s system of P; then by this proof I have proved P.
Now if this proof were one in Russell’s system - I should in this case have proved at once that it belonged and did not belong to Russell’s system.

That is what comes of making up such sentences.

But there is a contradiction here! - Well then there is a contradiction here.

Does it do any harm here?


Wittgenstein

Let it crash!

Concentrate on coding for the correct case and crashing on failure.

Robustness is achieved by having processes and messages between them.

Reliable Organisms from Unreliable Components
Error is viewed, not as an extraneous and misdirected or misdirecting accident, but as an essential part of the process under consideration.

J. von Neumann

Never certain
Lack of certainty is precisely what makes conclusions more reliable than the conclusions of those who are certain:

Because the good scientist will be ready to shift to a different point of view if better elements of evidence, or novel argument emerge.

Therefore certainty is not only something of no use but is in fact damaging, if we value reliability.

Carlo Revelli.

ORG’s for Robust privacy-friendly Cloud Forest Computing.
Client-Server, IMP-Overlord, supervisor, monitor, FSM, all actors after all.

Organizations of Restricted Generality (ORGs), provide foundations for the development of more scalable, robust, and privacy-friendly Internet applications by incorporating multi core cloud computing into the client.

Carl Hewitt.

Tropical Cloud Forest Distributed Artificial Intelligent.
Organization tools for message passing artificial monkeys.

We model organizations with monkeys and daemons, artificial intelligent monkeys abstraction inside nodes, clusters, cohorts and cubes; that talk with each other by messages.

Cebus Artificial Monkeys
Cebus distributes resources and tasks to processes of different types of actors on different nations, types and languages.

Eating mango’s manage the organization’s process resources in a little number of books and libraries of every used language and put some monkeys in charge of search and classify the books.

Working processes are activated only after measure the load of resource request at a time.

Caesar, had everything to do at one time
Having been trained by former engagements, they could suggest to themselves what ought to be done, as conveniently as receive information from others.

On account of the near approach and speed of the enemy, did not then wait for any command from Caesar, but themselves executed whatever appeared proper.

“They should keep up the remembrance of their wouden valor, and not be confused in mind but valiantly sustain the assault of the enemy”

Scalability
ONE MONKEY IS NO MONKEY!

Coherence
We refuse the distinction between the literal and the metaphorical as various philosophers of science have noted, the literal is always dead metaphor, a metaphor that is no longer seen as such.

We refuse the dualism between the real and the unreal, between realities and functions, thinking instead in terms of degree of enacted reality, or more reals and less reals.

We work allegorically

We imagine coherence without consistency.

Automate stuff with monkeys
Even non-programmers can benefit from knowing how to save time and effort.

The task-based Automate stuff with monkeys is designed to teach how to create basic systems of monkeys to automate stuff like search for text patterns, renaming a group of things, send emails and make phone calls.

This is a practical guide for the people and the Senate of Mars.

Machiavelli
Is contrast with Plato and Aristotle, Machiavelli insisted that an imaginary ideal society is not a model by which a prince should orient himself.

Empiricism and Realism versus Idealism.

Machiavelli is sometimes seen as the prototype of a modern empirical scientist, building generalizations from experience and historical facts, and emphasizing the useless of theorizing with the imagination.

Italian Benedetto Croce (1925) concludes, Machiavelli is simple a “realist” or “pragmatist” who accurately states that moral values in reality do not greatly affect the decisions that leaders make.

Archetype
A statement, pattern, behavior, or prototype which other statements, patterns of behavior, and objects copy or emulate.
A platonic philosophical idea referring to pure forms which embody the fundamental characteristics of a thing.

many more informal terms are frequently used instead such as “standard example” or “basic example” and the longer form “archetypal example” is also found.

In mathematics, and archetype is often called a “canonical example”.

Archetype can be understood as the principle pattern from which others are copied.

Flocks

A group of birds conducting flocking behavior on flight, or while foraging.

The term is akin to the herd among mammals.

The benefits of aggregation in flocks are varied and flocks will form explicitly for specific purposes.

Flocking also has costs, particularly to socially subordinate birds, which are bullied by more dominant birds; birds may also sacrifice feeding efficiency in flock in order to gain other benefits.

Multi-species flocks are usually composed of small numbers of many species, increasing the benefits of numbers but also increasing potential competition for resources.

Flocking rules
Basic models of flocking behavior are controlled by three simple rules:

Separation - Avoid crowding neighbors
Alignment - Steer towards average heading neighbors
Cohesion - Steer towards average position of neighbors

Monkey Mirrors
They are best known in the form of textbooks which directly instruct on certain aspects of rule and behavior, but in a broader sense, the term is also cover histories or literary works aimed at creating images of kings for imitation or avoidance.

Possibly the best known European “Mirror” is Il Principe 1513 by Machiavelli.

Checks and balances
To prevent one branch from becoming supreme and to induce the branches to cooperate government systems that employ a separation of powers need a way to balance each of the branches.

Typically this was accomplished through a system of “checks and balances”, the origin of which like separation of powers itself, Checks and balances allow for a system-based regulation that allows one branch to limit another.

Opposite running course
A principle that the superabundance of any force inevitably produces its opposite.

Similar to the principle of equilibrium in the natural world, in that any extreme is opposed by the system in order to restore balance.

When things get to their extreme, they turn into their opposite.

Messages and Signaling
Choose your tools carefully.

Innovation
The innovator makes enemies of all those who prospered under the old order, and only lukewarm support is forthcoming from those who would prosper under the new.

Their support is lukewarm partly from fear of their adversaries, who have the existing laws on their side, and partly because men are generally incredulous, never really trusting new things unless they have tested them by experience.

We must distinguish between innovators who stand alone and those who depend on others that is between those who to achieve their purpose can force the issue and those who must use persuasion.

It is ease to persuade them of something, but difficult to confirm them in that persuasion.

Python
After Satan was born, computers started getting more cores.

When threads are running on separate cores there are race conditions when two or more try to update the same object.

Especially with respect to the reference counts that are used in Python for garbage collection.

Multiprocessing, separate communicating processes rather than threads.

If you were to design a new language today, he said “Satan”, you would make it without mutable changeable objects, or with limited mutability.


Dispatch systems
It would be a piece of shit if every program we wrote were forced to do only one specific task.

Every time we wanted to do something different, we’d have to write a different program.

But if a language allows the same program element, to do different things at different times, we can write whole classes of programs at one.

Our point of view, which is independent of any particular object system.

However in class-based OO there is essentially no way to create an operation that dispatches on existing types.

This has been called “the expression problem”.

Technical programs deal with the same few types (numbers and arrays) and might want to write new operations that dispatch on them.

How hard it is to explain how effective multiple dispatch is, is itself quite interesting.
Stefan Karpinski

Many interpreted systems often end up having general types and inspecting the types of their objects at runtime and doing the appropriate code selection.

In Julia, with the combination of type inference, multiple dispatch and generic programming, our costs for both are significantly lower allowing us to write generic devectorized code.

C without types.

Coherent structure
for resource functionality.

The key idea is to integrate code selection, with code specialization, using generic functions and data-flow type inference.

Systems like these can suffer from inefficient compilation, or from uncertainty about what to specialize on.

The Key to software fault-tolerance
As with hardware, the key to software fault-tolerance is to hierarchically decompose large systems into modules, each module being a unit of service and a unit of failure.

A failure of a module does not propagate beyond the module.

The process achieves fault containment by sharing NO STATE with other processes.

It's only contact with other processes is via messages.

Jim Gray

The big idea is messaging
Alan Kay.

ZeroMQ Infrastructure
Who connects to whom?

You want the most stable part of the network to BIND on a specific port and have the more dynamic parts CONNECT to that.

Devices
These devices can bind 2 different ports and forward messages from one end to the other.

By doing so, the forwarding device can become the stable point in your network where each component can connect to.

ZeroMQ provides three kinds of devices:

Queue a forwarder for request/response

Forwarder a forwarder for publish/subscribe

Streamer a forwarder for pipeline pattern

Using such a device will remove the need of extra application logic, as you will not need.

A notion of Devices: simple programs that manage a send-recv pattern for connecting two or more sockets.

zmq.proxy

Description:

frontend socket, the socket instance for incoming traffic.
backend socket, the socket instance for outbound traffic.
monitor socket (optional), capture optional socket instance for capturing traffic.

Adds a method_mon version of each method_in|out for capturing the monitor socket.

A proxy is a 3-socket 0MQ Device that functions just like a QUEUE, except each message is also sent out on the monitor socket.

A PUB socket is the most logical choice for the mon_socket, but it is not required.

Add a resource
Pick a language [Julia, Python, Erlang, Lua]

Avoid changes to other applications
Focus on small and independent
Contribute to an ecosystem

Let it crash
If a processes crashes the runtime system detects this.

The runtime system protects the resources being used by the process.

Programs SHOULD crash when going off spec.

Treehouse
Analogous to a Zerg hatchery.

It is seems like the base or heart of the dungeon.

Colony
Tair 2 analogy

Pantheon
Tair 3 analogy

How we organize
Matters more than who we are

Problems ego and founders
The game have rules you play the game.

The better the rules the less up-front agreement we need to work together, most communities are killed by their founders egos.

Client-Server again
A client-server application is a distributed system consisting of both client and server software.

A client process always initiates a connection to the server, while the server process always waits for requests from any client.

The client-server relationship describes the relation between the client and how it makes a service request to the server and how the server can accept these requests, process them, and return the requested information to the client.
Workers can watch multiple or all tags/labels.

Client implement logic for heartbeating, and recovery from server restarts.

Server implement disconnection of idle clients.

The client MUST send heartbeats, when idle.

The heartbeat interval is typically one or several seconds, depending on client-side configuration.

A heartbeat command PING carries no data.

The server MUST respond to heartbeats by sending a Reply PING-OK, again carrying no data.

Clients must send at most a few PINGs if they are not getting PING-OK replies!

Servers must expire clients that have sent nothing within a certain timeout typically 10 to 30 seconds depending on the network.

Client automatically generate its own unique session ID, which cannot be over-ridden or used at any layer except this one.

The client sends its session UUID when connecting to the server, the server holds known client session in a data structure.

If the client connects with an existing session UUID the server attaches that new connection the the existing session.

If not, it creates a new session.

Some notes on Jupyter
The backend should have the following sockets:

Heartbeat: This is a REP socket which simply echoes anything it's given.

It is used to check up on the core, if the heartbeat port does not respond within a few seconds, Jupyter assumes the core is dead and restarts it or exists with an error.

Shell and Control: These two ROUTER sockets are what Jupyther uses to query the language backend.

Requests are sent through these sockets, and each request must have a corresponding reply.

Stdin: This ROUTER socket is which the language backend can use to query the front-end for input.

IOPub: This PUB socket is used to Publish all code output. When a task finishes or partially finishes running, messages are sent to all subscribed clients via this socket.

All output is sent via this mechanism the reply messages on the Shell messages are very simple only indicate success and failure.

Messages in Jupyter
A single core can be simultaneously connected to one or more clients.

Stdin: this ROUTER socket is connected to all clients, and it allows the kernel to request input from active clients.
Shell this single ROUTER socket allows multiple incoming connections from clients and this is the socket where requests for code execution are made to the core by any client.
IOPub this socket is the broadcast channel where the core publishes all side effects, there are a number of actions in which generate side effects, errors generate tracebacks, etc.

In a multi-client scenario, we want all clients to be able to know what each other has sent to the core.

This socket allows both side effects and the information about communication taking place with one client over the shell channel to be made available to all clients in a uniform manner.

Messaging for Parallel Computing
ZMQ messaging is used in the parallel computing system.

All messages to from engines remain the same a the single kernel model, and are forwarded through a ZMQ Queue device.

The controller receives all messages and replies in these channels, and saves results for future use.

The Controller
The controller is the central collection of processes in the Jupyter parallel computing model. It has two major components:
The hub
A collection of Schedulers

The Hub
The central process for monitoring the state of the engines, and all task requests and results.

It has no role in execution and does no relay of messages, so large blocking requests or database actions in the hub do not have the ability to block and impede task submission and results.

Registration (ROUTER)
The first function of the hub is to facilitate and monitor connections of clients and engines.

Both client and engine registration are handle by the Hub.

A heartbeat is used to monitor the survival of the engine process.

The controller replies to an Engine’s registration request with the engines ID, and all remaining connection information.

The message status will be an error if the engine request ID’s that already in use.

Heartbeat
The hub uses a heartbeat system to monitor engines, and track when they become unresponsive.

Notification (PUB)
The hub publishes all engine registration/unregistration events on a PUB socket.

This allows clients to have up-to-date engine ID’s sets without polling.

Schedulers
There are three basic schedulers:

Task Scheduler
MUX Scheduler
Control Scheduler

The MUX and Control schedulers are simple MonitoredQueue OMQ devices, with ROUTER sockets on either side.

This allows the queue to relay individual messages to particular targets via zmq.IDENTITY routing.

The Task scheduler may be a MonitoredQueue OMQ device, in which case the client-facing socket is ROUTER, and the engine-facing socket is DEALER!

The result of this is that client-submitted messages are load-balanced via the DEALER socket, but engine’s replies to each message go to the requesting client.

Note: Raw DEALER scheduling is quite primitive, and doesn’t allow message introspection.

Control Messages
Messages that interact with the engines, but are not meant to execute tasks, are submitted via the Control queue.

These messages have high priority, and this received are handled before any execution requests.

A book that deserves burning
It’s rare a book that deserves burning, but most books on concurrent programming do.

We don’t need mutexes, locks, or any other form of inter-thread communication except messages sent across sockets.

Code that’s easy to write and understand, that works with the same design approach in any programming language, and or any operating system, and that scales across any number of CPUs with zero wait states and no point of diminishing returns.

Just don’t share state.

Scale by sending messages.

Scale the stuff up
If you need to start more than one node in an application for example, you will want to run each in their own thread.

Do not use or close sockets except in the thread that created them.

Split off into separate processes as you need to.

Application logic can sit in processes, nodes, clusters, cohorts or cubes: whatever your scale needs.

A realistic server will start multiple workers processes.

It then accepts requests as fast as it can and distribute these to its worker processes.

The worker processes grind through the work and eventually send their replies back.

We use of course, a proxy and external worker processes, but often it’s easier to start one processes that gobbles up sixteen cores than sixteen processes, each gobbling up one core.

We battle monsters like networks hop, latency, and network traffic.

Node Coordination
The publisher knows in advance how many subscribers it expected.

This is just a magic number it gets from somewhere.


The publisher starts up and waits for all subscribers it expects.

When PUBLISHER has all SUB’s connected, it starts to publish data.

We’ll use a Request/Response socket flow to synchronize subscribers and publisher.


A more robust model could be :

Publisher open PUBLISHER socket and starts sending “PING” without data.


Subscribers connect SUB socket and when they receive PING message.


When the publisher has had all necessary confirmations, it starts to send real data.

Architecture of a single node (overlord)
Workers and clients are synchronous.

We want to use the load balancing pattern to route tasks to workers.

Workers are all identical; our facility has no notion of different services.

Workers are anonymous; clients never address them directly.

Clients and workers won’t speak to each other directly.

The beauty of scaling things up
You can design at the micro-level and scale that up to the macro level.

Processes become nodes, nodes become clusters, clusters become cohorts, cohorts become cubes.

and the patterns and logic remain the same.

Each of our overlord processes contains client threads, worker threads and a broker thread.

The basic node model
Request client create workload and pass them to the ROUTER
Request worker process workloads and return the result to the ROUTER.
The node queues and distributes workloads using the load balancing pattern.

Some things about ZeroMQ messages.
You may send zero-length messages e.g for sending a signal from one process to another.

ZeroMQ guarantees to deliver all the parts one or more for message, or none of them.

ZeroMQ does not send the message right away, but at some indeterminate later time.

A multipart message must therefore fit in memory.

A Message single or multipart must fit in memory. 

If you want to send files or arbitrary sizes, you should break them into pieces and send each piece as separate single-part messages.

Using multipart data will NOT reduce memory consumption.

Components and Services
There’s been a desire to build systems by plugging together components, much in the way we see things are made in the physical world.

Our definition is that a component is a unit of software that is independently replaceable and upgradeable.

Microservice architecture primary way of componentizing their own software is by breaking componentizing their own software is by breaking down to services.

Services are out-of-process components; Who communicate with a mechanism such as a web service request, or remote procedure call.

Microservice approach stuff splitting up into services organized around business capability.

Such services take a broad-stack implementation of software for that business area including user-interface, persistent storage and any external collaborators.

In another direction, one could argue that microservices are the same thing as the Erlang programming model, but applied to an Enterprise application context.

We think all these different techniques that people have worked on have uses and we just have to organize them into a larger architecture where there is also a vast amount of common sense knowledge about how to tell when one of these processes isn’t working and how to and give the symptoms have a failure, which other processes will won’t turn on, basically we have resourcefulness from having many resources not from having one very smart one.

Peering
Overlords are explicitly aware of each other and talk over privileged channel’s.

Assuming we want to interconnect N overlords.

Each overlord has (N-1) peers, and all overlords are using exactly the same code and logic.

There are two distinct flows of information between overlords:

each overlords needs to tell its peers how many imps it has available at any time.

This can be fairly simple information, just a quantity that is updated regularly.

Some patterns for this is are  [pub-sub. / sub-pub]

Every overlord opens a publisher socket and push state information on that, and every overlord also opens a subscribe socket and connects that to the publisher socket of every other overlord to get state information from its peers.


Each overlord needs a way to delegate tasks to a peer and get replies back, asynchronously.

Overlord Tasks Router
We’ll do this using ROUTER sockets; no other combination works.

Each overlord has two such sockets:

one for tasks it receives and one for tasks it delegates.

If we didn’t use two sockets, it would be more work to know where we were reading a request or a reply each time.

And of course the flow of information between a overlord and its local client and worker imps.

The Name Ceremony (and more on why names are complicated).
Three flows x two sockets for each flow = six sockets that we have to manage in the overlord.

So in all the code we will use these socket names:

node_front_end, node_back_end, cube_front_end, cube_back_end, self_front_end, self_back_end.

self for self flow
node for local flow
cube for control flow

It’s easier to remember the three flow to directions than six different sockets.

Random nonsense
Make it work
Start making apps with it
Notice everything inefficient in how you now write apps.
Update your bow
Repeat
Simple and explicit
Write your own user guide when things stabilize

Load balancer
A load balancer is a type of component that provides load balancing service.

The load balancer assigns workload to a set of networked computer servers or components in such a manner that the computing resources are used in an optimal manner.

A load balancer provides high availability by detecting server or component failure and reconfiguring the system appropriately.

Agent Actions (AI)
Any resource agent MUST support one command-line argument which specifies the action the resource agent is about to execute.

The following actions MUST be supported by any resource agent imp:

start starts the resources
stop shit down the resource
status queries the resource for its state
head dumps the resources headers.

Task Scheduler Algorithms
Connection Scheduling Algorithms inside the system.

I/O FUN schedules tasks at connection granularity inside the Linux kernel, here connection is defined as data communication between client socket and server socket, no matter whether it uses TCP or UDP protocol

We support different strategies for the connection scheduler algorithm:

Round-Robin
Weighted Round-Robin
Least-Connection
Weighted Least-Connection
Locality-based Least-Connection
Locality-based Least-Connection with Replication
Destination Hashing
Source Hashing
Shortest Expected Delay
Never Queue

Dynamic Feedback Load balancing Scheduler
The dynamic scheduler algorithm is to use connection scheduling algorithm and adjust server weight based on dynamic feedback information load of each server in order to avoid load imbalance among servers.

Cluster (Centuria)
At its core a cluster is a distributed capable of coordinating and recovery inter-related resources and services across a set of machines, typically 80 in CPU number, following the marian reform of the roman republic

Awareness of other applications


Automated recovery of instances to ensure capacity

Context is crucial to determine the difference between a local failure, clean startup or recovery after a total site failure.

Cluster Features

Detection and recovery of machine and application level failures.

support proactively and practically any redundancy configuration.

Support both quorate and resource-driven clusters.

Configurable strategies for dealing with quorum loss when multiple machines fail.

Support application startup/shutdown ordering, regardless of which machines the application are on

Support applications that must/must-not run on the same machine

Support application which need to be active on multiple machines.

Support applications which multiple modes.


What runs a virtual imp?
A highly scalable and highly available server built on a cluster of real hardware.

The architecture of server clusters is fully transparent to end users and the users interact with the cluster system as if it were only a single-performance virtual-server.

The agents interconnect the load balancers by either high-speed LAN or by geographically dispersed clouds like Amazon AWS or Google GCE.

The load balancer can dispatch requests to the different workers and make parallel services of the cluster to appear as a virtual service on a single address.

Scalability of the system is achieved by transparently adding or removing nodes in the cluster.

High availability is provided by detecting node or daemon failures and reconfiguring the system appropriately.

Don't make matters worse
Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash, Crash

And send errors out-of-band.

Ghost in the Shell

I run hacking tests where I build a security system.

I Have a network made up of the debuggers I use.

Section 9’s security codes have probably been overwritten.

Work as fast as you can.

Logicomas!

Wow, is this your personal Net, Major?

Yes. The Nets run by corporate admins don’t even compare.

This is a battlefield where distrustful barbarians gather.

Anyone want to join a game of mine?

Want to join?

What is this all about
A powerful, robust, flexible and easy to use stuff designed for automation and efficient management of real time agents, focus on teamwork and collaboration.

Design to improve productivity between agents and supervisors manage inbound and outbound campaigns through an agent console that is easy to use, a management interface and open source communication protocols.

Inbound Campaigns

Manages different types of incoming resources, each of them can be enabled with different strategies.

Outbound Campaigns
Operate with multiple contact sources managed by a time windows and concurrent channels.

It provides a do-not-contact list with every campaign.

Works with automatic strategies, calculating the required volume of output of resources depending on available agents, communication times; or progressive mode, making progress waiting first from a signal emitted by the human agent available to take them.

Campaign Monitor
Supervisors needs access to real-time status of each campaign, agents, and system in general.

But also resources in queues, waiting, abandoned, answered, and average times.

They require agent informations, average attention, brakes and status.

Measurement
Is the first step that leads to Control and eventually to improvement.

If you can't measure something, you can’t understand it.

If you can’t understand it,. you can’t control it.

If you can’t control it, you can’t improve it.

measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure, measure!!!

Python Central Logging with ZMQ
One interesting aspect of the zmq.SUB sockets is that they can connect to multiple endpoints, so that they receive messages from all publishers.

The solution is use one listener that “subscribes” to all the available publishers.

Interaction using messages
Must move ORGs while they are running, Inconsistency, Errors, Crash.

Conway’s law
Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.

M. Conway

In order for two separate software modules to interface correctly, the designers and implementers of each module must communicate with each other.

Therefore, the interface structure of a software system will reflect the social structure of the organizations that produced it.

Therefore: make sure organization is compatible with the product architecture.

Resource system
Resource sharing system, there's offloading that is done, planetary load balancing huge distributed problem.

Clients all the way up.

Cache in your pocket.

Organization Patterns
Erlang OTP analogy
Function Type
Process behavior type
Application level stuff
Distributed logic
System principles

Enterprise Business Plan
Pricing starts at $2500 per 10-user seat pack per year which includes maintenance, upgrades and technical support at no extra cost.

What is?
Enterprise is out our on-premises version of I/O FUN, which you deploy and manage in your secure environment, private or public cloud.

A seat is required for each person in your organization who will have I/O FUN Enterprise use account.

Want us to manage I/O FUN for you?
I/O FUN.IO is out hosted “SaaS” version of I/O FUN which we operate and maintain for you.

Pricing for organizations and groups starts at $25 month and is based on the number of campaigns you and your team need.

About User Story
A User Story tells a short story about someone using the product.

It contains a name, a brief narrative, and acceptance criteria and conditions for the story to be completed.

The advantage of user stories is that they focus on exactly what the user needs without going into the details on how to achieve it.

User stories are short simple descriptions of a feature told from the perspective of the person who desires the new capability, usually a user or customer of the system.

Simple template:

As a <type of user> I want <some goal> so that <some reason>

As an agent, I want I must action so that achievement.

as an agent, I want | must achievement.

Errors
Accept the fact that things are going to crash.

Accept the fact that there is going to be errors.

Things are going to crash in the system.

The system as a whole MUST not crash.

That's the fundamental principle on the error handling.

Do not try to handle errors locally because if the complete machine crashes how do you handle the error?

The small unit of fault-tolerance is two distributed computers.

Once you make it work on two the step to make it work on three  is very small.

Three, four, five, by then you got the basic principle.

Thing on this stuff for a second
Load unbalancing
Define a grid computer
Control plane, control socket, channel, control communication
Data plane, output, save the result of computation
Monitor, logging, handle errors out of band

Grid Cube Computing
The collection of computer resources from multiple locations to reach a common goal.

It can be thought of a distributed system with non-interactive workloads.

that involve a large number of files

the more important difference distinguished from conventional high performance computing systems of cluster computing is that grid cube computers have each node set to perform a different task/application.

A single cube can be dedicated to a particular application, commonly a cube is used for a variety of purposes.

A cube can get a size of 4800 CPU cores.

Cubes are a form of distributed computing whereby a “super virtual computer” is composed of many networked loosely coupled computers acting together performing large tasks

This is contrast to the traditional notion of supercomputer which has many processors connected by a local high-speed computer bus.

Overview
If you only have one process then crashing is a big deal and must be avoided at all cost but if we have millions of processes and some other process fixes the error then who cares?

Cube computing combines computers from multiple domains to reach a common goal, to solve a single task, and may then disappear just as quickly.

Cubes
Cube are a form of distributed computing whereby a super virtual computer is composed of many networked loosely coupled computers acting together to perform very large tasks

Coordinating  applications on Cubes can be a complex-task, especially when coordinating the flow of information across distributed computing resources.

Task scheduler

Control untended background executing worker ach processing

Synonyms are batch system distributed resource management system and distributed resource manager, task scheduler,. workload automation, typically provide a graphical user interface, a single point of control for definition and monitoring of background execution in a distributed networks of computers.

is required to orchestrate the integration of real-time business activities with traductions background IT processing ceros different platform and business applications environments.


Producer-Consumer Problem
Also known as the bounded-buffer problem is a classic example of a multi-process synchronization problem.

The problem describes two processes to producer and the consumer, who share a common, fixed-size buffer used as a queue.

The producer’s task is to generate a piece of data, put it into the buffer and start again.

At the same time, the consumer is consuming the data removing it from the buffer one piece at a time.

The problem is to make sure that the producer won’t try to add data into the buffer if it's full and that the consumer won't try to remove data from an empty buffer

The solution can be reached by means of interprocess communication.

The problem can also be generalized to have multiple producers and consumers.

Wittgenstein.

A is building with stones there are blocks, pillars, slabs, and beams.

B has to pass him the stones and to do so in the order in which A needs them for this purpose use if language consisting of the words “block. pillar, slab, beam”

A calls them out;

B brings the stone which he has learn to bring at such-and-such a call.

Conceive of this as a complete primitive language.



Confessions
When they grown-ups named same object at the same time runned towards it.
I perceived this, and I grasped that the thing was signified by the sound they uttered, since they meant to point it out.

This, however, I gathered from their gestures, the natural language of all peoples, the language that by means of facial expression and tone of voice, indicates the affections of the soul when it desires, or clings to or rejects, or recoils from something.

In this way, little by little, I learnt to understand what things the words, which I heard uttered in their respective places in various sentences, signified.

And once I got my tongue around these signs, I used them to express my wishes.

Augustine, Confession 1.8


Wittgenstein, Tractatus Logico-Philosophicus
We make to ourselves pictures of facts

The picture presents the facts in logical sopace the existence and non-exsitence of atomic facts.

The picture is a model of reality.

To the objects corresponde in the picture the elements of the picture.

The elements of the picture stand, in the picture, for the objects.

The picture consists in the fact that its elements are combined with one another in a defined way.

The picture is a fact.

Fail Fast
The process approach to faul isolation advocatea that the process software be fail-fast, it should either fuction correctly or it shopuld etrect the fault, signal failure and stop operaring 

If any erro is detected, they signal a fauilure and storps fail fast software has small fauil detection latency..

For an efectire error hamdling we must detecr erros and faulres as early as possible Renzel

Fail eirly


Messages
The big idea is messaging.


Processor
Halt on failure in the event of an error processor should halt instead of performing a possible erroneous operation.

Failure status property when a processor fauls other processors in the system must be informed.

The reason for failure must be communiocated.

The storage of a processor should be partitioned into stable storage which survices a processor crash and volatile storage which is lost if a processor crashes.

-Schneider

Honeycomb
A honeycomb is a mass of hexagonal wax cells built by honey bees in their nests to contain their larvae and stores of honet and pollen.

Numerous wasp specially construct hexagonal prism-packet combs made of paper instead of wax, however the term “honeycomb” is not ofetn used for such structres.

honeycomb geometry
A space filling or close packeing of plyhedral or higher-dimensional cells, so that there are no gaps.

It is an example of the more general mathematical tiling or tessallation in any number of dimensions.

Its dimension can be clarified as n-honeycomb for a honeycomn of n-dimensional space.

Honeycombs are usually constructed in ordinary Euclidean “flat” space.

They may also be constructed in non-eucludean spaces, such as hyperbolic honeycombs.

Classification
They are infinitely many honeycombs, which have only been partially classified.

The simples based on some tessellations of the plane, copies can fill space with the cubic honeycomb being special because it is the only regular honeycomb in ordinary euclidean space.

another interesting family is the hill tetrahedra and their generalizations, which can also tile the space.

The cubic honeycomb is self-dual.

Honeycomb structure
Honeycomb structures are natural or man-made structures that have the geomety of a honeycomb to allow the minimization fo the amount of used material to reach mionimal wight and minimal material cost

The feometry of honeycombn structures can varu widely but the common feature of all such structures is an arra of hollow cells formed betwen thin vertical walls.

The cells are often columnar and hexagonal in shape.

A honeycomb shaped structure provides a metrrial with minimal density and relative high out-of-place compression properties and out-of-place shear properties.

Man-made honeycomb structures materials are commonly made by layering a honeycomb material between two thin layers that prtovide strength intension.

This forms a place-line assembly.

The materials takes it name from its visual resemblance to a bee’s honeycomb

A hexagonal sheel structure.

Tessellation
A tessellation of a plat surface is the tiling of a place using one or more geometric shapes, called tiles, with o overlaps and no gaps.

In mathematics, tessellations can be generalized to higher dimensions and a variety of geometries.

Aperiodic tiling has a repeating pattern..

In geometry of higher dimensions, a space-filling on honeycomb os also called a tessellation of space.

A real physical tessellation of a tiling made of material such as cemented ceramic squares or hexagons.

Such tuiluing may be decorative patterns, or may have functions such as providing a durable and water-resistant pavement, floor or walls coverings.

Historically, tessellations were used in Ancient Rome.

M.C. Escher

In the twentieth centure the work of M.C Escher often made use of tessellations, both in ordinatry euclidean geometry and in huperbolic geometry.

Tessellations form a class of pattern in narure, for example int he arrays of hexagonal cells found in honeycombs.

Tesseract Cubes

In geometry, the tesseract is the four-dimensional analog of the cube; the tesseract is to the cube as the cube to the square.

Just as the surface of the cube consists of 6 square faces, the hypersurface of the tesseract of 8 cubical cells.

The tesseract is one of the six, convex regular 4 polytopes.

The tesseract is also called an 8-cell, C8 regular octachoron, octahedroid cubic prism, and tetracube, although this last term also mean polycube made of four cubes.

It is the four-dimensional hypercube or 4-cube as a part of the dimensional family of hypercubes or a measure polytopes.

Tiling window manager
A window manager with an organization of the screen into mutually non-verlappng frames, as opposed to coordinated-based stacking of overlapping ojects windows that tries fully emlatr the desktop metapor.

i3 window manager
Supports tiling, stacking, and tabbing layouts, which it handles dynamically.

Configuration is achieved via plain text file and extending i3 is possible using its Unix domain socket and JSON based IPC interface from many programming languages.

Liveness
Liveness refers to a set of properties of concurrent systems, that require a system to make progress despite the fact that it's concurrently executing components “processes” may have to “take turn in critical sections”

Critical parts of the program that cannot be simultaneously run by multiple processes.

C History
Thompson wanted to create a comfortable computing environment constructed according to his own design using whatever means were available. His plans, it is evident in retrospect, incorporated many of the innovative aspects of Multics, including an explicit notion of a process os a locus of control, a tree-structured file system, such as unified access to memory and to files.

During 1973-1980, the language grew a bit: the type structure gained unsigned, long, union, and enumeration types, and structures became nearly first-class objects (lacking only a notation for literals). 

Equally important developments appeared in its environment and the accompanying technology. Writing the Unix kernel in C had given us enough confidence in the language's usefulness and efficiency that we began to recode the system's utilities and tools as well, and then to move the most interesting among them to the other platforms. 


Unix Philosophy
Originated with Ken Thompson's early meditations on how to design a small capable system with clean service interface.

It is pragmatic and grounded in experience.

Doug Macllroy, the inventor of Unix pipes:

Make each process do one thing well.

To do a new task, build afresh rather than complicated old program by adding new features.


Expect the output of every process to become the input to another, as yet unknown program.


Design and build software systems, to be tried early, ideally within weeks.

Don’t hesitate to throw away the clumsy parts and rebuild them.


Use tools in preference to unskilled help to speedup a programming task.


Write programs that do one thing and do it well.

Write programs to work-together.

Write programs to handle text streams, because that is a universal interface.

More from quake
If a function is only called from a single place; conmsioder inlining it.

If a function is called from multiple places, see if it possible to arrange for the work to be dne ina sinle gplace, perhaps with flags, and inline that.

Igf thre are multiple versions of a function, consider maliong a sinle guncitons with more, possible defaulted paramters.

If the work is close to pure funcitonal with a fioew references to global state try to make it completely functional.

Try to use const on both parametes and funcitons when the fucntion really must be used in multiple places.

Minimize contro flow complexity and are imder oifs favptriomg sonsiten execution paths and time over optimally avoiding unnecessary work.

Amdahl's law

Used to find the maximum expected improvement to an overall system when only part of the system is improved.

Often used in parallel computing to predict the theoretical maximum speedup using multiple processors

The speedup of a program using multiple processors in parallel computing is limited by the time needed for the sequential fraction of the program.

Conway’s law
An adage that states:

Organizations which design systems are constrained to produce designs whch are copies of the communication structures of these concurrent and functional organizations.

M. Conway

Computer multitasking

A concept of performing multiple tasks also known as processes over a certain period of time by executing them concurrently.

New task start and interrupt already started ones before hay have reached completion, instead of executing the tasks sequentially so each started tasks need to reach its end before a new task is started.

AS a result, a computer executes segments of multiple tasks in a interleaved manner, while the tasks share common processing resources such as central processing units CPU and main memory.

Multitasking does not necessarily mean  that multiple tasks are executing at exactly the same time.
In other words, multitasking does not imply parallel executing, but it does mean that more than one tasks can be part-way through executing at the same time and that more than one tasks is advancing over a given period of time.

Even on multiprocessor or multicore computers more than one task can be executed at one physically one per CPU or core, multitasking allows many more tasks to be run than there are CPU’s

Scheduling
Multitasking solves the problem by scheduling which task may be the one running at any given time, and when another waiting tasks gets a turn.

The act of reassigning a CPU from one tasks to another one is called a context switch: the illusion of parallelism is achieved when context switches occur frequently enough.

Coroutine
Computer program components that generalize subroutines from non preemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations.

In contrast, preemptive multitasking interrupts applications and gives control to other processes outside of the applications control

Non-preemptive multitasking
Or cooperative multitasking is a style of computer multitasking in which the operating system nevers initiates a context switch from a running process to another process.

Instead, processes voluntarily stop their operation periodically in order to enable multiple applications to be run simultaneously.

This type of multitasking is called cooperative because all programs must cooperate for the entire scheduling scheme to work.

In this scheme, the process scheduler of an operating system is known as cooperative scheduler, having its role reduced down to starting htre proceses and lettin them retun control bnack to it voluntarily.

Behavior
The range of actions and mannerism made by individuals, organisms, systems or artificial entities, in conjunction with themselves or their environments which includes the other systems or organisms around as well as the inanimate physical environments.

It is the response of the system or organism to various stimuli or inputs, whether internal or external, conscious or subconscious, overt or covert, and voluntary or involuntary.

Batch processing
The executing of a series of programs tasks on a computer without manual intervention.

Tasks are set up they can be run to completion without human intervention interaction.

All input parameters are predefined through scripts, command-line arguments, control files, or task control language.

A program takes a set of data files as input processes the data, and [produces a set of output data files.

This operating environment is termed batch processing because the input data are collected into batches or sets of records and each batch is processed as a unit.

The output is another batch that can be reused for computation.

Task scheduler

a computer application for controlling unattended background program execution commonly called batch processing.

Synonyms are batch system distributed resource management system, and distributed resource manager.

Today often termed workload automation typically provide a graphical user interface and a signal point of control for definition and monitoring of background execution in a distributed network of computers.

Task schedulers are required to orchestrate the integration of real-time business activities with traditional background IT processing across different operating systems platforms, and business application environments.

Task scheduling should not be confused with process scheduling, which is the assignment of concurrently running processes to CPUs by the operating system.

Overview
Interfaces which help to define workflows and/or task dependencies.

Automatic submission of executions

Interfaces to monitor the executions

Queues to control the execution order of unrelated tasks

Notes on Task Scheduler
Most operating systems provide basic task scheduling capabilities but they will not usually provide the ability to schedule betong a single OS instance or outside the remot of the specific program.

Organizations using automate workload may also leverage further advanced features from task schedulers such as:

real time scheduling based on external, unpredictable events


automatic restart and recovery in event of failures


Alerting and notification to operations personnel


Generation of incident reports


Audit trails for regulatory compliance purposes


A Cooperative architecture a decentralized model where each machine is capable of helping with scheduling and can off lead locally scheduled tasks to other cooperating machines.

This enables dynamic workload balancing to maximize hardware resource utilization and high availability to ensure service delivery.

Batch queuing for clusters
An important niche for task schedulers is managing the task queue for a cluster of computers.

Typically the scheduler will schedule tasks form the queue as sufficient resources (cluster nodes) become idle.

In order to ensure high-speed processing, bath applications are often integrated with grid computing software to partition a batch task over a large number of processors, although there are significant programming challenges in doing so.

High volume batch processing places particularly heavy demands on system and application architectures as well.

Architectures that feature strong input/output performance and vertical scalability tend to provide better batch performance than alternatives.


Batch window
A period of less-intensive online activity, when the system is able to run batch tasks without interference from online systems.

With the advent of stuff the online applications might only be required from 9:00am to 5:00pm leaving two shifts available for batch work, in this case the batch window would be sixteen hours.

The problem is not usually that the computer system is incapable of supporting concurrent online and batch work, but that the batch systems usually requires access to data in a consistent state, free from online updates until the batch processing is complete.

In a bank for example so called end-of day (EOD)
 tasks include interest calculation, generation of reports and data sets to other systems, printing statements, and payments processing.


Internet bot
Simple a bot is a software application that runs automated tasks over the internet or network.

Typically, bots perform tasks that are both simple and structurally repetitive, at a much higher rate than would be possible for a human alone.

The largest use of bots is web spidering in which an automated program fetches analyses and files information from web servers at many times the speed of a human.

Bots allow people to ask questions plain english and then formulate a proper response.

These bots often handle many tasks including reporting weather, zip-code information, sport scores etc.

LXC Container Cubes
A cube is a virtualized operating system environment created within a single instance of the kernel OS.

Within a cube, the operating system is represented to the application as virtual operating system environments that are isolated and secure.

The applications run in different cubes with complete isolation.

Cgroups
Control groups are process containers.

Namespaces, independent namespaces.

Linux-based containers
Linux-based container infrastructure is an fast and lightweight process virtualization.

The idea of process-level virtualization in itself is not new, and it already was implemented by Solaris and BSD.

The underlying infrastructure of modern Linux-based containers consist mainly of two kernel features: namespaces and cgroups.

There are six types of namespaces, which provide per-process isolation of the following operating system resources:

filesystems (mnt), UTS, IPC, PID, network and user namespaces.

User namespaces allow mapping of UIDs and GIDs between a user namespace and the global namespace of the host.

By using network namespaces, each process can have its own instance of the network stack, network interfaces, sockets, routing tables and routing rules, netfilters rules and so on.

Creating a network namespace is very simple and can be done with the following iproute command:

ip netns add myns1

With the ip nets command, it also is easy to move one network interface from one network namespace to another, to monitor the creation and deletion of network namespaces, to fond out to which network namespace a specified process belongs and so on.

Quite similar, when using the MNT namespace, when mounting a filesystem, other processes will not see this mount, and when working with PID namespaces you will see by running the ps command from that PID namespace only processes that were created from that PID namespace.

The cgroups subsystem provides resource management and accounting. It lets you define, for example the maximum memory that a process may use, initially was called process containers.

Neither namespaces nor cgroups intervene in critical paths of the kernel, and thus they do not incur a high performance penalty. (“we hope”)

Cloud forest analogy

The forest wherever possible is build around simple ideas:

Every resource in the system either local or remote, is represented by a hierarchical tree; and a user or process assembles a private view of the system by constructing a file namespace that connects these resources.


Ten laws of Physics of People
Newton's First Law of Motion

Everything we do has an economic motive.

Things only move as a result of energy coming from somewhere else. People and organizations also follow this law. Economic motive is a force. The more accurate the economic motive, the more accurate the direction of movement.

Lesson: give every team and individual access to accurate economic incentives.


Newton's Second Law of Motion

The bigger the team, the more force it needs.

Sometimes it’s a bike. Sometimes it’s a car.

The smaller the thing you want to move, the easier and faster it moves.

If you try to change a 4800 person company, you need massive force.

To change a two person takes weed, pizza and a single client

Lesson: smaller teams move faster than larger teams, give the same force.


Newton's Third Law of Motion

When you push an organization, it pushes back.

Or, put this another way, if you try to change a 4800 person company, you will be fired.

Unless you’re the CEO, then you’ll given a huge bonus, and then fired.

Lesson: build fresh organizations instead of changing existing ones.


The Equivalency Principle

Failing is indistinguishable from laking progress.

You can only judge success by aiming for the pavement, and failing.

Lesson: the bigger your leaps, the more damaging your failures.


Murphy’s Law

If it can break, it will in the worst possible way, at the worst possible time.

Perfect systems don’t exist, or at least we cannnot make them.

Rather than trying to prevent failures, we need to learn to embrace failure, and make it part of our process.

Leasson: embrace failures as the best way to leatn what works.


The Uncertainty Principle

The more you know about one type of topic, the stupider you become.

Never trust someone who has all the answers, expecialy yourself. Experts are dangerous, diversity is more valuable than expertise.

Lesson: diversity is not a political slogan it’s the basic for collective intelligence.


Zipf’s Law of Power Distribution

20% of any system always has 80% of the power.

It applies to cities, languages, earthquakes, and economies and organizations, and software systems.

Leasson: if shitty code solves the problem, it’s not shitty code.


Moore’s Law
Cool processors and stuff gets 50% cheaper every 18-24 months.

Software lives on an exploding cloud of silicon.

Leasson: The size of our systems - the number of movies pieces doubles every 18-24 months, and no-one understand any system.


Amdahl’s Law


Conway’s Law

Abstraction

Any problem in computer science can be solved by adding another level of abstraction.

paraphrase of Alan Perlis


We need something like ZeroMQ
We need something that does messaging, but does it in a simple way that it can work in any application, with close to zero cost.

Specifically:


Handling I/O asynchronously, in background threads. These communication with application threads using lock-free data structures, so concurrent applications need no locks, semaphores, or other wait states.


It lets route messages using a variety of patterns such as request-reply and pub-sub.

These patterns are how you create the topology, the structure of your network.


It lets you create proxies to queue, forward, or capture messages with a single call, proxies can reduce the interconnection complexity of a network.


It does not impose any format on messages.

They are blobs from zero to gigabytes large.

When you want represent data you chose some other product on top, such as msgpack.

It handles network errors intelligently, by retying automatically in cases where it makes sense.

Messaging Patterns
Lets recap briefly what 0mq does for you. It delivers blobs of data (messages) to nodes, quickly and efficiently.

You can map nodes to threads, processes, or nodes, it gives you appliocations a single socket API to work with, no matter the actual transpiort like.

It auomatically reconnects to peers as tey come and go.

It queues messages at moth sender and receives, as needed. It limits these queues to guard processes agains running our of memory.

uit handles socket errors.

it does all IO in backrgound threads.

It uses lock-free technies for taling between n nodes, so there are neves locks, waits, semaphores, or deadlocks.

But cutting through that, it routes and queues messages acourding to proces receipes called patterns.

it is these pattrns that prioved zeromq intelligence.

The build-in core 0mq patterns are:


Request-Reply which connects a set of clients to a set of services.

This is remote procedure call and task distribution pattern.

Publushi-Subscribe, which connects a set of publishers to a set of subscribers.

This is a data distribution pattern.

Pipeline, which connects nodes in a fan-out fan-in pattern that can have multiple steps and loops.

Thos is a parallel task distribution and collection pattern.

Exclusive pair, shich connects two sockets exlusively.

This is a pattern for connection two threads in a pcrocess, not to be confused with “normal” pairs of sockets



Remember

small steps = function calls
big steps = processes

and functions calls run sequentially process run in parallel

so we have a nive way to think about parallel algorithms

Pipes

We should have some way of couplin programs like garden hose scrow in another segment when it becomes necessary to message data in another way

This is the way of IO

he conceived UNIX pipes, whic allows programs to work together with no knowledge of each other.

Garden hose connection analogy, thoigh, is the one that ultimately whacked us on thwe head to best effect.

Plumbers

The pipe location in you home is important for poper maintenance and water flow.

If you have no idea where a leak is coming from youkl’ll want to call aprofessional plumber who will have the equipment to locate the pipesd in your walls, floors and ceilings.

Handyman tips

When you move into a new house or porperty try to locater the main stopcock whicj shits off the water supply to the house

Do not wait until you hve a major problem, then it will be too late

Fit service values to all your puipes, this will allow you to work on the bathroom sink without it affectin the water suppli in the bathj, shower or toulet, this gives every item its own identity and allottin off the water supplu in the entire house.

Sell X

X = Julia, Python, Erlang, Lua, C, Javascript
Of course you can’t sell X you must sell a product written in X

Your advantage is time to market

Expect problems

Smart guys with new smart ideas represent a threat to established order

Get a protector @umbrella

Make a group, the group is the smalles unit of survival inside a company.

Look for projectrs failures

Dont fiht bad bosses move immediately

If your projectr is cancelled rename it

Make your mind up

product company you make a product that you sell

Research and Development, you develop a product and sell the company or product to a bigger company that cannot develop the product itself

All these have different risk profiles.

The Method

Coose a upcoming standard or invent something new

Make the worlds best and fist implementation of the standard

Gain a reputatuion as the expert

Sell or give away the software

The goal is build a reputation

Sell the company

Important note

You are Not selling Julia, Python Erlang, Lua, C, Javscript

Your are selling a THING written in Jupyter, Lua, C, Javascript

Your advantage is time to market

You must have a business plan

Concentrate on areas where big companies would love to be active and where there is intesne competition to be fistr and where the profit margins are high

What is a businnes plan?

What are we selling?

How much does it cost?

How are we going to sell it to?

How can we reach, convince, sell to our customers?

How can I the investor may money from this?

and…

Know your numbers, burn rates, profit margins.

Prepare the [1,2,3,5,8] minute elevator pith

get an amazing good salesperson, pay them a medium amount with a huge bonus for sales

collect letters of interest, patents, newspapes acticles, twitter followers, etc

Hire perpanent staff, getr premises, get customers.

All the numbers from these will end up in a VC’s spreadsheet which effect the value of your company

Names

Names are imprecise

Names imply a namespace

the names thing might change

deciding a name is difficult

unique names are difficult to make

What do the laws of physics have to say about computation?

Causality

A cause must always precede its effect

Ubfirnatuib trravesl at or less than the speed of leght

We do not know that something has happened until we get a message saying that the event has happened

we do not keno hot things are now at a remote location only how thety were thet last time we got a message from them

Entropy
Entropy always increases

The entropy increases the number of files

Files mutate

Disks are huge

What bname should a filehave

Which directory should I stoire the file in

WHat machine should I store the directory in

How will I find the file later

How can I replicathe the file

URI’s are bad

DNS can be spoofed

The host can be unavailable

If the store is changed the reference is wrong

Can be cached, but for how long?

Content can be changed by a person in the middle

Used hashes instead of names

Address cannot be spoofed, there is no address

No problem choosing a name, there is no name

Can be cached forever

Content can be validated on arrival

Not subject to person-in-the-middle attacks

Note on Julia

You should be able to use multiple Julia tasks, one for each socket.

This is how Jupyter works, since it needs to read from multiple sockets.

Julia Tasks “Coroutines”
Tasks are control flow features that allows computations to be suspended and resumed in a flexible manner.

Tasks are sometimes called by other names such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations.

When a piece of code, executing a particular function is designated as Task, it becomes possible to interrupt it switching to another Task.

The original Task can later be resumed , at which point it will pick up there it left out. At first, this may seem similar to a function call. However there are two key differences.

first, witching tasks does not use any space so any number of task switchs can occur without consuming the call stack.

Second, switching amoung tasks can occur in any order, unlike funtion calls, where the called function must finish executing before control returns to the calling function.
Julia Core Task operation
yieldto(task, value) suspends the current task, switches to the specified task, and causes that tasks last yieldto() call to return the scppecific value.

Notice that yieldto() is the only operation required to use task-style control flow, instead of calling and returning we are always just switchiing to a different task.

This is why this feature is called “symmetric coroutines”; each task is switched to and from using the same mechanism.

yieldto() is powerful, but most uses of tasks do not invoke it directly.

Consider why this might be.

If you switch away from the current task, you will probably want to switch back to it at some point, but knowing when to switch back, and knowing which task has the responsibility of switching back can require considerable coordination.

In addition to yieldto(), a few other basic functions are needed to use tasks effectively.

current_task() gets a reference to the current_running tasks.
istaskdone() queries whether a task has exited.
istaskstarted() queries whether a task has run yet
task_local_storage() manipulates a key-value storage specific to the current task.
Tasks and events
Most task switches occur as a result of waiting for events such as I/O request, and oprformed by a scheduler included in the standard library.

The scheduler maintains a queue of runnable tasks and executes and event loop that restarts tasks based on external events such as message arrival.

The basic function for waiting for an event is wait(). Several objects implement wait(); for example given a process object, wait() will wait for ir to exit.

Wait is often implicit; a wait() can happen inside a call to read() to wait for data to be available.

In all of these cases, wait() operates on a Condition object, which is in charge of queuing and restaring tasks.

When a task calls wait() on a Condition, the task is marked as non-runnable, added to the conditions’ queue, and switches to the scheduler.

The scueduler will then pick another task to run, or block waiting for external events.

If all goes well, eventually an event handler will call notify() on the condition, which causes tasks waiting for that condition to become runnable again.

A task created explicitly by calling Task is initially not known to the scheduer.

This allow you to manage tasks manually using yieldto().

However, when such a task waits for an event, it still gets restarted automatically when the event happens, as you would expect.

It is also possible to make the scheduler run a task whenever it can, without necessarily waiting for any events. This is done by calling shedule(), or using the @scheduler or @async macros.
Task states
Tasks have a state field that describes their execution status. A task state is one of the following symbols:

:runnable Currently running, or available to switched to.

:waiting Blocked waiting for a specific event.

:queued In the scheduler’s run queue about to be restarted

:done Successfully finished executing.

:failed Finished with an uncaught exception
Julia Parallel Computing
Julia provides a multiprocessing environment based on message passing to allow programs to run on multiple processes in separate memory domains at one.

Communication in Julia is generally “one-sided”, meaning that the programmer needs to explicitly manage only one process in a two-process operation.

Furthermore, these operations do not look like message send and message receive but rather resemble higher-level operations like calls to user functions.

Parallel programming in julia is build on two primitives: remote references and remote class.

A remote reference is an object that can be used from any process to refer to an object stored on a particular process.

A remote call is a request by one process to call a certain function on certain arguments on another or possible the same process.

A remote call returns a remote reference to its result.

Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else.

You can wait for a remote call to finish by calling wait() on its remote reference, and you can obtain the full value of the result using fetch.

You can store a value to a remote reference using put!()

The first argument to remotecall() is the index of the process that will do the work.

Most parallel programming in Julia does not reference specific processes or the number of processes available, but remotecall() is considered a low-level interface providing finer control.

The second argument to remotecall() is the function to call, and the remaining arguments will be passed to this function.

Occasionally you might want a remote-computed value immediately. This typically happens when you read from a remote object to obtain data needed by the next local operator.

The function remotecall_fetch() exists for the purpose. It is equivalent to fetch(remotecall(...)) but is more efficient.

The syntax of remotecall() is not especially convenient.

The macro @spawn makes things easier, it operates on an expression rather than a function, and picks where to do the operation for you.

Each process has an associated identifier.

The process providing the interactive Julia prompt always has an id equal to 1, the processes used by default for parallel operations are referred as “workers”.

WHen there is only one process, process 1 is considered a worker.

Otherwise, workers are considered to be all processes other tan process 1.
Data Movement
Sending messages, and moving data constitute most of the overhead in a parallel program.

Reducing the number of messages and the amount of data sent is critical to achieving performance and scalability.

To this end, it is important to understand the data movement performed by Julia’s various parallel programming constructs.

fetch() can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine.

@spawn and a few related constructs also moves data, but this is not as obvious, hence it can be called an implicit data movement operation.

In a real program designing data movement might require more thought and likely some measurement.
Synchronization With Remote References
Julia’s parallel programming platform uses Tasks aka Coroutines to switch among multiple computations.

Whenever code performs a communication operation like fetch() or wait(), the current task is suspended and a scheduler picks another task to run. A task is restarted when the event it is waiting for completes.

For many problems, it is not necessary to thing aboyt tasks directly. However, they can be used to wait for multiple events at the same time, which provides for dynamic scheduling.

In dynamic sheduling, a program docides what to computer or where to compyter uir based on when other jobs dfinish.

This is nedded for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they finish they current tasks.

@async is similar to @spawn, but only runs tasks on the local process
Tasks and Parallel Computing
Task(func)
Create a Task to execute the given function which must be callable with no arguments.

The task exists when this function returns.

yieldto(task, args)
Switch to the given task.

The fisrt time a task is switched to, the task function is called with no arguments.

On subsequent switches, args are returned from the tasks last call to yieldto.

This is a low-level call that only witches tasks not considereing states or scheduling in any way.

currnt_task()
Get the current running Task.

is taskdone(task) -> Bool
Tell whether a task has exited.

consume(task, values)
Receive the next value passed to produce by the specidified task.

Additional arguments may be passed, to be returned from the last produce call in the producer.

Produce(value)
send the given value to the last consume call, switching to the consumer task. If the next consume call passes any values, thjety are returned by produce.

yield()
Siwtch to the scheduletr to allow another sheduler task to run. A task that calls this function is stuill runnable, and will be restarted immediately if there are no other reunnable tasks

task_local_storage(symbol)
Look up the value fo a symbol in the curren tasks task-local storage.

task_local_storage(symbol, value)
Assign a value to a symbol in the current task’s task-local storage

task_local_storage(body, symbol, value)
Call the function body with a modified task-local storage, in which value is assigned to symbool; the previous value of symbol, or lack thereof, is restored afterwards useful for emulating dynamic scoping.

Condition()
Create an edge-triggered event source that tasks can wait for. Tasks that can wait() on a Condition are suspended and queued. Tasks are woken up when notify is later called on the Condition.

Edge triggering means that only tasks waiting at the time notify is called can be woken up.

For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The RemoteRef type does this, and so can be used for level-triggered events.

notify(condition, val=nithing; all=true, error=false)
Wake up tasks waiting for a condition , passing them val. if all is true (the default), all waiting tasks are woken, otherwise only one is. If error is true, the passed value is raised as an exception in the woken tasks.

schedule(t::Task,[val]; error=false)
Add a task to the scheduler’s queue.

This causes the task to tun constantly when the system is otherwise idle, unless the task perfotrms a blocking operation such as wait.

If a second argument is provuided, it will be passed to the task via the return value of yieldto when it runs again.

Uf err us trye, the valye uis raised as an exception in the wokne task.

@schedule()
Wrap an expression in a Task and add it to the scheduler’s queue.

@task()
Wrap an expression in atask executing it, and return the task. this only creates a task and does not run it.

sleep(seconds)
Block the curren task for a spcified number of seconds. The minimum sleep time is 1 millisecond or input of 0.001.

General Parallel Computing
wait([x])
Block the current task until some event occurs, depending on the type of the argument:

RemoteRef: Wait for a value to become available for the specidied remote refrence.
Condition Wait for notify on a condition.
Process Wait for a process or process chain to exit. The exitcode field of a process can be used to determine success or failure.
Task: Wait for a task to finish, retuning its result
RawFD Wait for changes on a file descriptor.
If no argument is passed, the task blocks for a undefined period.

If the task’s state is set to waiting, it can only be restarted by an explicit call to shecdule or yiledto.

If he task’s state is :runnable, it might be restarted unpredictably.

Often wait is called within a while loop to ensure a waited-for condition is met before proceeding.

@async()
Schedule an expression to run on the local machine, also adding ir to the set of items that the nearest enclosing @sync waits for.

@sync()
Wait until all dynamically-enclosed uses of @async, @spawn; @spawnat, and @parallel are complete.


Inconsistency Robustness
Inconsistency robustness is information system performance in the face of continually pervasive inconsistencies.

A shift from the previous dominant paradigms of inconsistency denial and inconsistency elimination attempting to seep them under the rug.

Inconsistency robustness is both an observed opphenomenon and a desired feature:

it is an observed phenomenon because large information systems are required to operate in an environment of pervasive inconsistency.

How are they doing?


It is a desired feature because we need to improve the performance of large information systems.
Empresas
Siendo el isntituto de estas empresas criar un daemon desde la cuna hasta la tumba, debo ajustar a cada una de sus edades el estilo y la doctrina como hicieron platon y arustioteles; y asi advierto que en la infancia se facilite con el movimiento el uso de sus brazon y piernas; que si alguna por su blandura se trociere, se enderece con artiificiosos instriumentosl que no se le ofrecscan objetosd espantoso que ofendan su imainative o mirados de solayo que desconierten los ojos que le hagan poco a poco a las indemencas del tiempo que con la armonia de la musica avivien su espiruiti que sus jkkiguetes sean libros y armas para que les cobr afucuion porque nuevo slo ninos y los daemons en las cosas las admiran empirememn facilmente enla fantasia.

La historia es maestra de la verdare politica, y y qyuiebn mezon y el arte corrigen y pulen syus obras.

Oteas veces la naturalza se esfuerza por excederse asi mismay junta monstruosamente grandes virtudes y grandfes ciios en un sujeto, no de totrs durte que cuando en dos ramas se ponen dos injertyos contrtios, que siond, uno mismo el tronco rinden diversos frutos uno dulces y otero amargos.


Old man Aristotle
If every tool, when ordered, or een of its own accord, could do the work that benefits it… then there ould be no need either of apprendtices for rhw master workers or of slaves dfor the lords

-Aristotle



Construction
Construction is a very geberakl term meaning the art and science to form material or immaterial objkects, systems or organizations and comes from latin constructionem from com ttogether and struere to pile up and Old french construction.

Constructon, is used as a verb: the act of building, and a noun: how a builidng was build, the nature of its structure.

Lua
A lightweight multi-paradigm language designed as a scripting language with extensible semantics as a primary goal

Because many potential users were not programmers the language avoid cryptic syntax and semantics.

Lua creators state that lisp and scheme with their single ubiquitous data structure mechanism the list were a major influence on their decision to develop the table as the primary data structure of lua.


Lua Features
Lua is a commonly describes as a multiparadigm language, providing a small set of general features that can be extended to fit different problem types, rather than providing a more complex and rigid specification to match a single paradigm.

Lua does not contain explicit support for inheritance, but allows it to be implemented with metatables.

Similarly lua allows programmers to implement namespaces, classes, and other related features using its single table implementation first-class functions allow the employment of many techniques from functional programming and full lexical scoping allows fine-grained information hiding to enforce the principle of the least privilege.

In general , Lua strives to provide flexible meta-features that can be extended as needed, rather than supply a feature-set specific to one programming pradigm.

Lua implements a samll set of advanced features such as fist -class functions, farbage collection, closures, proper tail calls, coercion, coroutines, and dunamic module loading.

Lua Internals
Lua programs are not interpreted directly from the textual Lua file, but are compiled into bytecode which is then run on the Lua virtual machine.

Like most CPUs, and unlike most virtual machines shioch are stack-based, the Lua VM is registerre design.

The register architecture both avoids excessive copying of values and reduces the total number of instructuions per function.
Lua C API
Lua intented to be embedded into other applications, and privdes a C A{PI for this purpose.

The API is divided into two parts the Lua core and the Lua auxiliary library.

The Lua API’s design eliminates the need for manual reference mangementr in C code inlike Python’s C A{PI.

The API, like the language is minimalistic Advanced functionality is provided by the auxiliarity library which assist whth complex table operations.
About Lua
Lua is a powerful, fast, lightwight, embeddable, scripting language.

Lua combines siomple procedural syuntax with poweful data deve arrays and extensible semantics.

Lua is dynamically typed, runs by interpretuing bytecode from a regtrer-baed virtual machine, and has automatic memory managment with incremental gfarbagfe collection.

A fundamental concept in the desing is to provide meta-mechanisms for impmenting featrues, instead of providng a host of features directly in the language.

For example, although Lua is not a pure OOP language, it does provide meta-mechanisms for implementing classes and inggerutabce,

Luas meta-mechanisms bring a econom of concepts and keep the language small, swhile allowing trhe semantrics to be extended in unconventuonal ways.

Lua is proven, robust language.
Principle of least privilege
In information security, computer science, and many other fields the principle of least privilege also known as the principle of minimal privilege or the principle of least authority requires that in a particular abstraction layer of a computing environment; every module such as a process, user or program depending on the subject must be able to access only the information and resources that are necessary for its legitimate purpose.

The principle means giving a user account only those privileges which are essential to that user’s work.

When applied to users, the terms least user access or least-privileged user account are also used, referring to the concept that all user accounts at all times should run with as few privileges as possible, and also launch applications with as few privileges as possible.

Benefits of the principle include:

Better system stability.

When code is limited in the scope of changes it can make to a system, it is easier to test its possible actions and interactions with other apps.

In practice for example, applications running with restricted rights will not have access to perform operations that could crash a machine, or adversely affect other applications running on the same system.


Better system security.

When code is limited in the system-wide actions it may perform, vulternatibilities in one application cannot be used to exploit the rest of the machine.


Ease of deployment.

In general, the fewer privileges on application reques the easier it is to deploy within a larger environment.

This usually results from the first two benefits applications that install device drivers or requere elevated security privileges typicall have additional steps involved in their deployment.

Every program and every privileged user of the system should operae using the least amount of privilege necessary to cpoomplete the job.

- Jerome Saltzer, Communications of the ACM
Coroutine

Coroutine are computer program components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming executing at certain locations.
Courotines are well-suited for implementing more familiar program components such as cooperative tasks, exceptions, event loop, iterators, infite lists and pipes.

Comparasion with subroutines

When subroutines are invoked, execution begins at the start, and once a subroutine exists, it is finished; an instance of a subroutine only returns once, and does not hold state between invocations.

By contrast, coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the orginal coroutine;

Thus, a couritne instance holds state, and varies vetween invocations; there can be multiple instancesof a given coroutine by yielding and calling another routine, is that the latter is entered in the samecontinuous manner as the former.

The relation between two coroutines which yoields o each other is not that of caller callee, but instead symmetric.

Subroutine
A subroutine is a sequence of program instructions that perform a specific task, packaged as unit.

This unit can then be used in programs whrever that particular task should be performed.

Subprograms may be defined within programs, or separately in libraries that can be used by multiple programs.

In different languages, a subroutine may be called a procedure, a function a routine, a method, or a subprogram.

The generic term called unit is sometimes used.

Coroutine Common uses
Coroutines are useful to implement the following:

State machines within a single subroutine, where the state is determined by the current entry/exit point of the procedure; this can result in more readable code, and may also be implemented via mutial recursion with tail calls.


Actor model of concurrency


Generators, and these are useful for streams particularly, input/output and for generic traversal of data structures.

Nonpreemptive Multitasking
Nonpreemptive multitasking is a style of computer multitasking in which the operating system never initiales a context swith from a running process to another process.

Such systems are either statically scheduled most often periodic systems, or exhibit some form of cooperative multitasking, in which case the computatuibak tasks can self-interrupt and voluntarily give coontrol to otgher tasks.

When non preemptive is used, a process that receives such resources can not be interrupted until it is finished.
Cooperative multitasking is a type of multitasking in chich the process currently controlling the CPU must opffer control to other processes.

It is called cooperative because all programs must cooperate for it to work. In contrast preemptive multitasking interrupts applications and gives control to other processes outside of an applications control.
Coroutines in Lua
Coroutines allow us to execute several tasks at once. this is done ina  controlled manner by passing control to each routine and waiting until the routine says it has finished.

We can reenter the routine to continue at a later time and by doing this repeatedly we achieve multi-tasking.

Coroutines in Lua are not operating system threads or processes. Coroutines are blocks of Lua code which are created wihin Lua, and have their own flow of control.

Only one coroutine ever runs at a time, and it truns until it activates another coroutine, or yields return to the coroutine that invoked it.

Coroutines are a way of express multiple cooperating subroutines of control in a convenient and natural way, but not execute in parallel, and this gain no performance benefit from multiple CPU’s.

Yielding
In order for multiple coroutines to share execution they must stop executing after performing a sensible amount of processing and pass control to another subroutine.

This act of submission is called yielding.

Coroutines explicitly call a Lua function coroutine.yield(), which is similar to using return in functions.

What differentiates yielding from function returns is that at a later point we can re-enter the subroutine and carry on where we left off. when you exit a functions cope using return the scope is destroyed and we cannot re-enter it.


Lua Coroutines
Lua support coroutines, also called collaborative multitasking.

A coroutine in Lua represents an independent block of executing. Unlike threads in multithread systems, however, a coroutine only suspends its execution by explicitly calling a yield function.

You create a coroutine with a call to corutine.create; It’s sole argument is a function that is the main function of the coroutine.

The create function only creates a new coroutine and returns a handle ho it an object of type thread; it does not start the coroutine execution.

When you first call coroutine.resume, passing as its first argument a thread returned by corutine.create, the coroutine starts its execution, at the fist line of its main function.

Extra arguments passed to coroutine.resume are passed on to the coroutine main fucntion.

After the coroutine starts running it runs until it terminates or yields.
Campaigns
Full games in the original sequence were released in episodes known as campaigns.

Players must purchase an individual campaign in order to access the game elemtnts specific to that campaign; all campaign is idependent of the others, with its own co-operative storyline, campaign specific skills, and competitive arenas.
Accounts
A new player must create a game account suign a unique email address and an access key received from the purshace of the game or rhrough the online store.

An account is initially set to a specific region depending on the version of the game purchased; Europe, America, Japon.

Players may freely move amopng those regions regardless of the accounts home region players in all regions can meet and froms parties in international distriets instances of in-game outopiosts,.

These fistricts are also in larnguage of the orgiinal region.


Higher-order function
In mathematics and computer science a higher-order function also functional form, functional or functor is a function that does one atleast one of the following:

takes one or more functions as an inpout
outputs a function
All other functions are fist-order functions in matghermatics higher -order functions are also knows as operators or functionals.

The derivative in calculus is a common example , since it maps a functon to another function.

In the untyped lambda calculus, all fucntions are higher-order.


Blizzard Linked lists
Implement important features including fog-of-war, line-of-sight, flying unit patching-repulsing, voice-chat, AI reinforcement pints, and fixing bugs.

Linked lists were used extensively in the engine to track units with common behavior.

It became essential to optimze the search for units of specific types by keepin them linked together in lists.

All of these lists were double-linked to make it possible to add and remove elements from the list in constant time - O(1)

Without the necessity to traverse the list looking for the element to remove - O(N).

Storm.DLL which shipped with Diablo, among its many features, contained an excellent implementation of doubly-linked lists using templates in C++.

And event if you dont use linked-lists the same solutions carry over to more complex data structures like hash tables, b-trees and priority queues.


Python Function decorators
Function decorators enable the addition of new functionality to a function without altering the functions orgiinal fucntionality.

Functions can be passed as arguments to otther functioopns

Functions can be retturned from otherf cuntons calls.

Functions can be defined inside other functions resulting in closures.

Put simple, function decorators are wrappers that let you execute code before and after the function thay decorate without modifying the function itself.
Function Decorators
The ability to add new function to a function without modifying the original function is the essence of function decorators.

Once this concept is understood, the concept of decorators is understood.

Python introduces the @ symbol for decorating functions.
Linked list again
In computer science, a linked list is a data structure consisting of a group of nodes which together represent a sequence.

Under the simplest form, each node is composed of data and a reference in other words, a link to the next node in the senquence; more complex cariants add aditional links.

This structure allows for efficient insertion or removal of elements from any position in the senquence.

Doubly linked list
In doubly linked list, each node contains besides the next-node link, a second link field point to the previous node in the sequence.

The two links may be called forwards and backwards, or next and previous.
Related Data structures
Both stacks and queues are steps implemented using links lists, and simpe restrict the type of eperations which are supported

The skip list is a linked list augmented with layes of pointers for quickly, jumping over large numbers of elements, and then descending to the next layer.

Thios process continues down to the bottom layer, which is the actual list.

A binary tree can be seen as a type of linked list where the elemtns are themsels linked lists of the same nature.

The result is that each node may inlcude a reference to the fist node of one or two other linked lists, which, rogether wi

A hash table may use linked lists to store the chains of items that shas to the same position in the hash table.

Concurrent
For multiprocess programs, message passing is a natural fit.

Many of the kinds of programs you want to implement using multiple processes lends themselves naturally to a message passing architecture.
Python multiprocessing pools
The multiprocessing module has a very useful abstraction, in the form of the Pool class.

Some of the different pool methods:

apply_async

Takes a functon and some arguments, and sends it to one of the worker processes to be run.

Replies immediately wioth a result obnject,, which is kind of like a future.

You can get the returned value from it once it’s done.


Linux Containers
Is the umbrella projectr behind LXC, LXD, LXCFS, AND CGManager.

The main focus is system containers.

That is, containers which offer an evironment as close to possible as the one you’d get from a VM but without the overhead that comes with running a separate kernel and simularing all the hardware.

This is achieved throught a comabinatrion of kernel security features such as namespaces, mandatory access and control groups.

LXC
Well known tool, templates, library and language bindings.

LXD
Offers a completely fresh user experience single command line tool to manage your containers. Containers can be managed over the network in a transparent way through a HTTP API.

LXCFS
Userspace FUSE Filesystem offering two main things:

Overlay files for cpuinfo, meminfo, stat, and uptime.

A cgroupfs compatible tree allowing unprivileges writes.

Its designated to worrkarond the shotcomings of procfs, sysfs, and cgroups by exporting files which match what a system container user would expect.

CGManager
cgroups manager daemon.

It’s designed to allow nested unpriveled containers to still be able to create and manage their cgrouups through a DBus API.
Clustering
clustering is a unsupervised learning problem whereby we aim to group subsets of entities with one another based on some notion of similarity.

Clustering is often for exploratory analysis and / or as component of a hierarchical supervised learning pipeline in which distinct classifiers or regfgression models are trained for each cluster.

k-means clustering, one of the most commonly used lcutsering algorithms that clusters the data ponints into predefined number of clusters.

k is the number of desired clusters.

maxiteration is the maximum number of iterations to runn via k-means.

runs is the number of times to run the k-means algorithms, k-means is not guaranteed to find a globally optional solution, and when run multiple times on a given dataset the algorithm returns the best clustering result.
initializations steps determines the number of steps in the k-means algorithm.

epsilon determines the distance threeshold within which we consider k-means to have converged.
Streaming clustering
When data arrive in a stream, we may want to estuimate clusters dynamically, updating them as new data arrive.

I/O Fun provides support fior streaming k-means clustetring, with paramters to control the decay of forgetfulness of the estimates.

The algorithm uses a generalization fo the mini=batrch k-means update rule.

For each batch of dfata, we assign all pionts to their neares cluster, compute bnew cluster centers, then update each cluster.

Where the previoyus center fot he cluster is the number of pints assigned to the cluster this far, is the new cluster center from the current batch, and the number of pnts added to the clstyer in the current batch.

The decay factor can inning with only the most recent data wuill be used.

This is analogous to an exponentiallyu-weighted noving average.

The decay can be specified usign a half-life parametyer, which determines the correct decary factroe a such that, fotr data acquired at time ists contribution by time halgig lige wuill have dropped to 0.5

The unit of time can be spcecified either as bathces or ponts and the updatye rule will be adjusted accordigly.
Iterator
In object-oriented computer programming, an iterator is an object that enables a programmer to traverse a container, particularly lists.

Various tyopes of iterators are provided via a containers interface. Though the interface and semantics of a given iterator are fixed, iterators are often implemented in terms of the structures underlying a container implementation and are often tightly couplead to the container to enable the operational semantics of the iterator.

An Iterator is behaviorally similar to a database cursor.

External iterator
An external iterator may be thought of as type of pointer that has two primary operations: referencing one particlar element in the object collection, called element access, and modifying itself so it points to the next element called element traversal.

There must also be a way to create an iterator so it points to some fist element as well as some way to determine when the iterator has exhausted all of the elements in the contaner.

Depending on the language and intended use, iterator may also provuide additonal operations or exhubit different behaviors.

The primary purpose of an iterator is allow a use to process every element of a container shilw isolating the user from the internal structure of the container.

This allows the container to strorre elements in any manner it sishes shilw allowing the user to trat it as if it were a simple sequence or list.

an iterator class is usually designed in tight coordination with the corresponding container class.

Usuarlly, the container provides the methods for crearing iterators.

Generators
One way of implementing iterators is to use a restricted form of coroutine, known as a generator.

BY contrast with a subroutine, a generator coreoutine can yiield values to its calller multiple times, instead of returning just one.

In python, a genetator is a interator constructor: a function that returns an iterator.
Python iterators
A fundamental part of the language and in many cases go unseen as they are implicitly used in te for foreach statement in list comprehensions, and in general expressions.

Al of Pythons standard buit-in collection types supoport iteration, as well as many classes that are part of the standard library.
Generator
A generator is a special routine that can be used to control the iteration bejaviour of a loop

In Fact, all generators are iterators.

A generator is very similar to a function that returns an array i, in that a generator has parameters, can  ebe called, and generates a sequences of values.

However, instead of builing an array containing all the calues and returning them all at once, a generator yields the values one at a time, which requiores less memory and allows the caller to get started processing the first few values immediately.

In short, a generator looks like a function but behaves like an iterator.
Bit
A bit is the basic unit of information in computing and human digital communications.

A bit can have only one of two values, and may thjerefore be physically implemented with a two-sttate device. These values are most commonly represented as either a 0 or 1.

The term bit is a portmanteau of binary digitl.

The two values can also be interpreted as logical values tree/false, yes/no algebraic signs +-, activations states on/off, or any other two-valued attribute.

The correspondence between these values and the physical states of the underlyiing storage or device is a matter of convention and different assignments may be used event within the same device or program.

\The length of a binary number may be referred to as its bit-length.

In information theory, one bit is typically defines as the uncertainty of a binary random variable that is 0 oor 1 with equal probability, or the information that is gained when the value oif such a variable becomes known.

In quantum computring, a quantum bit or qbut is quantum system, that can exit in superposition of two bit values, truw and false.

Bit
1, 4, 8, 12, 16, 18, 24, 26, 31, 32, 36, 48, 60, 64, 128, 256, 512

Application
16, 32, 64

Floating point precision
x%2, x1, x2, x4

Floating point decimal precision
32, 64, 128
Behavior
Is the range of actions and mannerism made by individuals, organisms, systems, or artificial entities in conjuction with themselves or their environment, which includes the other systems or organisms around as well as the inanimate physical environment.

It is the response of the system or organism to various stimuli or inputs, whether internal or external conscius or subconcious, overt or covert, and voluntary or onvoluntary.

Management
In amanagement, behaviours are associated with desired or undesired focuses.

Managers generally note what the desrired outcore is, but behavioral patters can take over. These patterns are the reference to how often the desired behavior actually occurs. Before a behavior actually occurs, antecedents focus on the stimuli that influence the behavior that is about to happen. After the behavior occur, consequences fall into place.

System
A system is a setof interacting or interdeppendent components forming a integrated whole.

Every system is delineated by its spatial and temporal boundaties, surrounded and influenced by its environemnt, described by its structure and purpose and expressed in this functioning.

Some systems share common characteristics, including:

A system has structure, it contains parts or components that are directly or indirectly related to each other;


A system has behaviour, it exhibits processes that fulfill its function or purpose;


A system has interconnectivity; the parts and processes are connected by strcutural and/or behavioral relationships.


A system’s strcuture and behavior may be decomposed via subsystems and sub-processes to elementary parts and process steps.


A system has behavior thta, in relativity to its surroundings, may be categorized as both fast and strong.


The terms syetsm may also refer to a set of rules that govers structure and/or behavior

Alternativly, and usually in context of complex socuial systems, the term institution is used to describe the set of rules that govern structure and/or behavior.

Institution
Institutions are stable, valued, recurring patterns of behavior.

A structures or mechanism of scoail order they fovern the behavior of set of individuals within a given coimmunity.

Institutuons are indentified with a socual purpose, transcending individfual and intentions by mediating the rules that govern living behavior.

The term institution is commonly applied to customs and behavior batterns important to a society as well as to particulatrr formal organizations of governement and puublic services.

AS strcutures and mechanisms of soocial orrder, institutures are one fo the prioncipal ojects of study in the social scoiences, such as poolitical science, anthropology, economics, and socialogy, the science of institutions, their genesis and their functioning.
Conway’s law
Organizations which design systems are constrained to rpduce designs which are copies fo the communication structures of these organizations.

It is based on the reasoning that in order fot two separate software modules to interface correctly the designers and iplementers of each module must communicate with each other.

Therefore, the nterface strcutures of a software system will reflect the social strcutures fothe organizations that produce it.
Amdahl’s Law
Used to fin the maximum expected improvement to an overal system when only part of the system is improved.

It is often used in parallel computing to predict the theoretical maximum speedup using multiple processsors.

The speedup of a program using multiple processors in parallel computing is limited by the timeneeded for he sequential fraction of the program.

If a program needs 20 hours suign a single processor core, and a particular portion of the programs takes one hour to execute cannot be parallelized, while the ramaining 19 hours 95% of executiion time can be parallelized, the minimum execution time cannot be less than that critical one hour.

The spped up ios limited to at most 20X.

Semantics
Is the study of meaning.

It focuses on the relation between signifiers, like words, phrases, signs, and symbols, and what they stand for their denotation.

Linguistic semantics is the study of meaning that is used for undestanding hyma expression through language.

Other forms of semantics include the semantics of programming languages, formal logics, and semitics.

The studo of semantics is also closely linked to subjhects of representaton, refrerence and denotation.

The basic study of semantics is oriented to the examination of the meaning of signs, and the study of relations bnetween different lunguistic units and compuninds: homonymy, synonymy, antonymy, hypernynmy, hyponymy, meronymy, metonymy, holonymy, paranyms.

Denotation
Is a translation of signs to its meaning, more exactly, to its literal meaning.

Denotation is sometimes constrasted to connotation which translaes a sign to meanings associatred with it.

In logic, linguistics and semiotics, the denotation of a word or phrase is a part of its meaning; however, the part referred to varies by context:

In grammar and literary theory, the literal meaning or dictionary definition of a term, devod of emotion, attitude, and color.


In semiotics the surface or literal meaning of a signifier.


In logic, formal semantics and parts of linguistics, the extension of a term.


In Computer science, denotation semantics is contrasted with operational semantics.
Semiotics
Is the study of meaning-making, the philosophical theory of signs and symbols.

This includes the study of signs and sign processes, indication, designation, likeness, analogy, metaphor, symbolism, signification and communication.

Semiotics often is divided into three branches:

Semantics: relation between signs and the things to which they refer; their denotata, or meaning.


Syntactics: relation among signs in formal structures.


Pragmatics: relation between signs and sign-using agents.


In general, semiotic theoris take signs or sign systems as their object of study.

Syntacts is the branch of semiotics thatr deals with the form properties of signs and symbols. It deals with rules that govern how words are combined to form phrases and sentences.



Semiosis
To mark, is any form of activity, conduct, or process that involves signs, including the production of meaning.

The term was introduced to describe a process that interprets signs as referring to their objects.

Queue
In computer science, a queue is particular kind of abstract data type or collection in which the entities in the collection are kept in order and the princiapl operations on the collection are the addition of entities to the rear terminalpostion, know as enqueue, and removal of entities fromthe fron terminal position, knows as dequeue.

This maes the queue a FIFO data structure. In a FIFO data structure, the fist element added to the queue will be the fist one to be removed.

This is equivalent to the requirement that once a new element is added, all elements that were added before have to be removed before the new element can be removed.

A queue, is a example of alinear data strucutre, or more abtractlyy a sequentuial collectyion.

Queues porovide services in compuuter science transpoert, and operations researchh where variopurs entities such as data, obhjects, persons, messages, and events are stored and held to be processed later.

In these context, the queue fperforms the function of a buffer.

representation of a FIFO fist in fist out queue.
Some words on Queues
Queues are an incredibly useful tool in modern computing, tghey are often used in order trro perform some possibnle slow computation at a later time in web applications.

Basically queues allow to splita computation in tqwo times, the time the computation is scheduled, and the time the computation is executed.

A producer, willput a task to be executed into a queue, and a consumer or worker will get takss from the queue to execute the,

The actual process of processing the mesage may rquer reting if there are transient network faulures or other errors, is up to the worker.

Technically speaking we can think at queues as form of inter-process messaging primitive, where the receiving process needs to acknowledge the reception of the message.

Messages can not be fire-and-forget since the queue needs to understand if the message can be removed from the queue, some acknowledgement is strictly required.

When the worker process acknowledges the reception of the message before processing the message, if the worker fails the message can be last before the task is performed.

If the acknowledgme is sent only after the mesage gest processed, if theworker fails or because of network particutions the queue may re-deliver the message agfain.

This happends whatevet the queue consistency properties are, so, even if the queue is modeled using a syustem providing strong consistency, the indeterminantion still holds true:

if messages are acknowledge before processing, the queue will have an at-most-once delivery property.

This means messages can be processed zero or one time.

If messages are acknoledge after processing the queue will have an at-least-once delivery property.

This means messages can be porocessed from 1 to infinite number of times.


Creativity
Creativity dies not involve a single brain region or single side of the brain.

instead , the entire creative process from preparation to incubation to illumination to verification consists of many intereacting cognitibv processes both conscious and uncoscious and emotions.

Depending on the stage of the creative process, and whjat you’re actually attempting to ceate, different brain regions are recruiterd to handle the task.

Importantly, many of these brain regios work as a team to get the task done, and many crecruit structures from both the left and right side of the brain.

Cognition results from the dynamic iteractions of distributed brain areas operating in large-scale networks.

Depdning on the task, different brain networks will be recruited.
Python Process-based parallelism
multiprocessing is apackage that supports spawning processing using an API similar to the threading module.

The multiprocessing package offers both local and remote concurrency, effectively side-steoppping the global interpretir lock by using subprocess instead of thereads.

The Process class

In multiprocessing, process are spawned by creating a Process objhect and then calling its start method.

Contexts and start methods

Depending on the platform, multiprocessing supports three ways to start a process.

These start methods are spawn, fork and forkserver.

Spawn
The parent process starts a fresh python interpretec process.

The child process will onmly inherit those resources necessary to run the process onjkects run method.

In particular, unncessary file descriptiors and headles from the parent process will not be inherited.

Starting a process using this method is rather slow compared to using fork or forkserver.

Fork

The parent process usus os.fork to fork the python interpreter.

The chuild process, when it begins, is effectively identical to the part process.

Al resources of the partent are inherited by the guild process.

Note thatr safely forking a multithreades process is problmatic,

Forkserver

when the program starts and slects the forkserver start method, a server process uis started.

Fiomr then on, whenerver a new process is needed, the parent connects to the sever and requests that if forks a new process.

The fork server procew s is single heread so iuts is safe it to use os.forks

No unnecesary resources are ingeruted,

On UNIX using the spwn of forkservr startt methods will also start a semaphore tracker process whicjk tracks the unlinked named semaphores created by processes of the program.

When all processes have exited the semaphore tracker unlinjks any remaining semaphores.

Usually there shold be non, but if a process was likked by a signal there may be some leakead semaphores.

Unlinking the named smaphores ia serious matter since the system allows only a limited number, and thety will not be auomatically unliked until the next reboot.

To select a start method use the set)stary_method() in the main module.


Pipes and queues
When using multiple processes, one generally uses message passing for communication between processes and avoids have to use any synchronization primitives like locks.

For passing messages one can use Pipe() for a connection between two processes or q Queue which allows multiple producers and consumers.

The queue, Simplequeue and JoinableQueue types are multi-producer, multi-consumer FIFO queues modelled on the queue.Queue calss in the standard library.

If you use JoinableQueue then you must call JoinableQueue.task_done() for each task removed from the queue or else the semaphore used to count trhe number of unfinshed tasks may eventually overflow, rainising an eexpception.

Note: multiprocesses uses the usual queue.Enmpty and queue.Full exceptions to signal a timeout.

They are nor available in the ultuiprocessing namespace so you need to import thwem from queue.
More Message passing
Message passing sends messages to proceses or actors and relies on the process and the supporting infrastructure to select and invoke the actual code to run.

In response to a message, and actor can make local decisions, create more actors asend more messages, and determine how to respond to the next message received.

An acvtor is a computational entity that, in response to a messsage, it receopive can conccruntly: 

Send a gfinite number of messages to other actors.

Create a finite number of new actors.

Desginate the behavior tto be used fro the neext message it receives.

There is no assumed sequence to the above actions and they could be carried out in parallel.

Decoupling the sender from communications sent enable asynchronous communication anc control structures as patterns of paassing messages.

Recipients of messages are identified by address, cometimes called mailing address

this an actor can only communicate which actor swhose addresses it has.

It can obtain those from a message it receives o fro an actor ir has itself created.

The actor model is chatracterized by inherent concurrency of computation whthin and among actors, dyunamic creation of actors, inclusing of action addresses in messages, and interaction only through direct asyunchtonos message passing with no restrinction on message arrival order.

Messages are simple sent like packets in IP there is no requirement for a sycghonous hadshare with rhe recipient,.

Message passin is used ubiquitously in moden computer software. It is used as a way for the processes that make up a system to work with each otgher and as a waty for actors and systems rynning on different computers to interact.

Message passing is a technique for incoking bvehavior on a computer. The invoking program sends a message and relies on the process to select and ececute the appropriate code.

Ther justification for using a higher level of abstraction the message passing layer essentially falls into encapsulation and distribution

Encapsilation is the idea that sofware processes should be able to incoke services on other processes without knowing or caring about how those serves are implemented.

Encapsulation can reduce the amount of coded logic and make systems more maintibale.

E,g trather than haicn gi then statesmes that determine wihich subroutine or funciton to call a developer can jsut send a message to a propcees and the process willselect the appropriate code based on pattern matching.

Distributed message passing provdies developers with a layer of the architecture that ptovdes common serrvides to build systems made up of sub-systems that run on disparate computers in different locations and a different times.

When sending a distributed syste, a message the messaging layer can tale cae of issues as:

Finding there approprite procees, including procsses rungin on different computyers usning differen topperring sustyes and programming laguages, at different ocations from whetre the message originated.

Saving the messager on a queue igf the appropriate proceess to handle the message is not currently runnigna dn then onoking the messager when the proceess is available .

Alos storing thr result if needed until the sending procews is read to receive it.


Fundamentally similar
Machine thinking

Computational processes

Computation machine thinking reducible to message sending

Message receiving

Message receiver crearing

Message processing incluiding how to process future messages.
Actors
Organization:

The local storage of an actor can include addresses only.

That were provided when it was created
That have been received in messages

OperationL
In response to a message received, an actor can.

Create more actors.
Send messages to addresses in:
the message it has just received
its local sorage
Actor Misunderstanding
Question: Isn’t procedure calling faste than messagfe passing?

Answer: No, they are equivalent.

Question: doesn’t every actor have X where X is thread, mailbox, queue?

Answer: Is X an Actor?

Question: What is an Actor?

Answer: Anything that obey the axioms!
Idempotence
The property of certain operations in mathematics and computer science, that can be applied, multiple times without changing the result beyond the initial application.

The reques methods of the HTTP computer protool are a common example of idempotence in that data retrieval operations can be prformed without changing or otherwise affecting fdata.

It literally means the quality of having the same power.

from idem + potence (same + power)
Carrier
Carries are large, heavily armored and schieled ships.

Thjey form the core of the gleet serving as command centers fo fleet commanders.

They lack other armament beyond interceptors.

The computer controlled interceptor are unleashed in swarms agains the other ship in battle.

The interceptor are a type of robotic strike craft

Thety are primary wepon of carriers

Interceptors are fast, maneuverable, computerguidance strike craft. They may deploy to engage enemy strike crasgt or ground units.

Carriers manufacture interceptioors. When deploy the strike crasgt attack and retrat rpidtly to the carrier for reps and reactrmed the detisl  

Nothing is particular hard if you divide it into small tasks.
Introducing Organizations 
Organizations simplify managment of group-owned resourcs, expand on our permission system, and hep focus your workflow for business and large open source projects.

You can manage multiple accoutns with a company specific dahboard, manage read-only collaborators or give someoe else administraive control over one of your resources your ogoig to love organizations..

Creating an orgnizations helps you centraliza your organizations resources.

All resouces under the organizaon and biloing goes throing a central organizaiton accounts.

Any owner of an organization may edit that organizaotns setitings, from progile details to billing informations.

Teams give people access to the organizations resouces, making it easy to add or remove people to mamy resouercesa at once.
Both users and resources may be address to teams by owners, and you can make as many teams as you wwant.

Fcous on your organization

Each organization you belong to has its own dashboard context.

With this context, you;’ll see events pertinent to the organization as wll as the resources that beloong to the organization that you have access to.

Context are stictly.

Once youve selected a context clicking the meny or any dashboard link will brong you back to your context.

Select your name from the dropdown to get back to your personal dashboard

Dasboards context are all about focus.

Come to work, switch to your company context go home siwtch to your personal context.

Interaction creates reality

Do not keep saying to your self if you can possible avoid it but how can it be like that? because you will go down the drain, into a blind alley from which nobody has yet escaped.

Nobody knows how it can be like that.

Ricard Feyman.

Cube

In geometry, a cube is a three dimensional solid object bounced by six squere faces, facets or sides with three meeting at each vertex.

The cube is also a square parallelioped, parallelepiped and equilateral cuboid and right rhombededron.

It is a regular square prism in three orientations, and a trogonal trapezohedron in four oriwentations.

The cube is dual to the octahedron

It has cubidial or octahedral symmetry.

Client-Server model

A distribuded application steructure that partituons tasks or workloads between the prviders of a resource or service, called servers, adn service requesters, called clients.

Often clients and servers communicate over a computer network on separete hardware, but both client and server may rside in the same system.

A server host runs one or more server programs which shrare theires resopurces with cliens

A client does no share anyof the resours but requests a servers content or service function

Clients threfore initiate communication session with servers shich await incoming requests.

Client and server roles

The client-server characteristic describes the realtionship of cooperating programs in an application.

The server component provides a function or service to one or manyy clients, which initiate requests for such services.

Servicers are classified by the services they provide for instance a web server.

Whether a computer is a client a server or both a determined by the natuyre of the application that requires the service functions.

Client and server communication
In general, a service is an abstraction of computer resources and a client does not have to be concerned with how the server performs while fulfilling the requestr and delivering the response.

The client only has to understand the response based on the well-klnown application protocol, i.e the content and the formatting of the data for the requested service.

Clients and Servers Exchange Messages
The client sends a reques, and the server retusn a response. This exchange of messages is a axample of inter-rprocess communication.

To communicate, the computers must have a common language, and they must follow rules so that both the client and the server know what to expect.

The language and rules of communication are defined in a commmunication protocol

Al client-server protocols operate in the application layer.

The apllication-layer protocol defines the basic patters of the dialogue.

To formalize the data exchange even futher, the server may implement an API.

THE API is an abstraction layer for such respurces as databuses and custom sofyware.

In each step of this sequence of clien-server message exchangfes, a computer processes a request and retusn data this is the rques-respnse messagin pattern. when all the requests are met the sence is complete and the web browser presents the data to the customer.

this exmple ilusttratyes a desing pattern applicale to the client-server model.

separations of concerns.

Inter-process communication
IPC is the activity of sharing data across multiple and commonly specialized proceses using communication protocols.

Typically, applications using IPC are categorized as clients and servers, where the client requests data an the server respons to client requests.

Omnibus
An old term for a horse-drawn enclosed bus, being the latin for “for all”.

Quakeworld network
Quake elementary unit of communication is the command.

They are used to update a player position orientation, health, damage, etc.

So to summarize: The engine deals mostly with commands.

When it needs to send or receive, it delegates the task methods.

Reliable messages from quakeworld engine
Unreliable commands are grouped in UDP packet, marked with the last outcoing sequence number and sent;

Ity doesnt’ matter to sender if they get lost.

Reliable commands are dealt with diffently the key is to undettad that hey can be one one reliable packet unacnoledged between a sender and a receiver.

Every game loops, if a new reliable comad is generated is a dded to ther mesage buffer array piloted via the message variable.

The set of tiable commands is the moved from mesage to the reaible buffer array.

This happens only if reliable_buf is empty if it is not empty, this means that an other set of commands was sent before and has not yet been acknoeledged.

On the receiving end, the UDP message is parsed, the incoming sequence number is transfered to the outgoing sequence ACK, along with the bit glag indicating the packet containing reliable data.

On the next message received:

If the relibale bit flag is set to true the UDP packet made it to the receiver.

If the relibale bit gflag is set to false the udp did not made it to the reciever so will try to send the content of relibale buf again.

New commands will pile up in message buf if this array overflows, the clinets is dropped.

Semantic integration
The process of interrelating information form diverse sources, for example calendars and todo lists, email archives, presense information documents, of all sorts, contacts, search tresults.

In this regards, semantics focus on the organization of an action upon information by acting as an intermediary between hetergoneous data sources, which may conflicty not only by strucutr not also onxtect or value.

Machine
A machine is a device that uses energy to perform some activity or task.

Machine  or machines can also refer to:

Term of art mechanical using mecahnical energy.

Computing machine, slang for computer or server.

Abstract machine, a theoretical model of a computer hardware of software system used in automata theory.

A bot a computer system that does automated tasks.

devices that perform tasks.

A machine si atool containing one or more parts thatr use energy to perform an intented action.

A simple machine is a device that simple transforms the direction or magnitude of a force, but a large number of more complex machines exists.

Derives form the latin machina.

The word could also means a sheme or plot a meaning now explessed by the derived machination.

Modern 1704 meaning:
Machine or engine, in machinicks, is watsoeven hath force suffcient either to taise or stop the motion of a body.

Simple machines are commonly reckoned to be six in number, vox.

The vallance, leaver, pulley, wheel, wedge, and screw.

Computing machines or engines are innumerable.

The word engine used as a near-synonym from latin engenium engenuity an invention.

Computing machines, store and manipuitklate the flow of electrons, with patterns in this storage and flow being interpreted as information manipulation.

Controllers combine sensors, logic, and actuators to maintain the performance of components of a machine.

Mecha an Auto
Mechanization is providing humans with machinery that assists them with the muscular requirement of work.

Automation is th use of control system,s and information technologies to reduce the need for humanwork in the production of goods and services.

Automatrion decreeses the ned of human sensory and mentail requirements as well.

Automata a self-opetraitng machine the word is sometimes used to describe a robot, more specificallty an autonomous robot.

Control System
A control system is a device, or a set of devices that manages commands, directs or eregulates the behavior of devices or sustems.

There are towo comon classes of control systems open loop control systems and closed llop control systems.

In open loop control systems outoput is generalosed loop control systems current output is taken into consideration and corredtion are made based on feedback.
A close loop system is also called a feedback control system.

Remainder
No language or system is good at everything use the right tool for the job.

LXC
A userspace interfacer for the linux kernel containment features. Throught a powerful API and simple tools it lets linux users easily create and manage system or application containers.

Current LXC user the folowing kernel featrures tro contain processes:
kernel namespaces (ipc, uts, mount, pid, network and user)
apparmor and selinux profiles
seccomp policies
chroots using pivot_root
kernel capabilities
cgroups

LXC containers are often considered as something in the middle between a chroot and a full fledge virtual machine.

Goal of LXC
The goal of LXC is to create an environment as close as possible to a standard Linux installation but without the need for a separate kernel.

LXC Requirements
Come by default with everything thats needed for safe, unpriveled, LXV containers.

On such an Debian system, installing LXV is as simple as:

apt-get install lxc

Your system will then have all the LXC commands available, all its templates as well as the python3 and lua binding should you want to script LXC.


Quake 3 Arena
Quake 3 which was a quake 3 game and network technolohgy with a new grapics engine.

We changed our minds.

The new produc is going to be called Mars, and will consist exclisively of dethmatch style gamming including CTF and other derivates.

The single player game will just be a progrssion throuigh a raning ladder against bot AIs.

The emphasis will be multiplayer experience and making evey aspect as robust and high quality as possible, rather than trying to add every conceibale ioption anyone could want.

I wanted to write about my evolving thoughts on code quality and lessons learned throught quake and quake 2, but in the interest of actually completing an update, I decided to focus on one change that was intended to just clean things up, but had a surprinsing number of positive side effects.

Since doom, our games have been defined with portability in mind.

Porting to a new platyform involves having a way to display output, and having the platform tell you about the various relevant inputs.

There are four principle inpuits to a game: keystrokes, mouse moves, network opackets, and time.

If you don’t consider time an input value, think about it unitil you do, it is an important concept.

These inputs were taking in separate places, as seemed logical at the time.

A function name system send key events was called once a frame that would rummage throug wehatrver ir needed to on a sstem leven, and call back onto game fucntions like key event and in mouse moved.

The network system dropped into sustem specifi code to check for trhe arrival fo packets.

Calls to sys milliseconds were littered all over the code for various reasons

I was reevaluating all of the system interfaces for q3.

I settled on comining all forms of input into a single system event queue, similar to the wndows message queue!

My original intention was to just rigorously define where certain functions were called and cut down the number of required sytem entry points, but it turned out to have much stronger benefits.

With all events coming throught one point the return values from system calls, including the file system contents, are hiden inputs that I make no attempt at capturing, it was easy to set up a journalling system that recorded everything the game received.

Realtime applications have a number of unique develiopment difficulties because of the interaction of time with input and outputs.

The key pints: Journaling of time along with other inputs turn a real-time application into a batch process, with all the attendant benefits for quality control and debugging.

These problems, and many more, just go away.

With a full input trace, you can accurately restart the session and play back to any point (conditional breackpint on a frame number), or let a session play back a an arbitrarily degraded speed, but cover exactly the same code paths.

Its nice to see a problem clearly in its entirely for the first time, and know exactly how to address it.

I had been working under the assumption that Java was the right way to go, but recently I reached a beter conclusion.

The programming language for Mars is interpreted ANSI C.

dropping the double data type, but otherwise it should be pretty confoirmant.

The game will have an interpreter fro virtual RISC-Like CPU.

This should have a minor speed benefitr over a byte-coded, stack based java interpreter.

Middleware
Computer software that provides servides to software applications.

Beyond those available from the O.S it can be described as software glue.

Middleware makes it easier for developers to perform communication and input/output so they can focus on the specific purpose of their application.

Middleware is the sofware layer that lies betyween the operationg system and the aplications on each side of a distributed computer network.

The term is most coommonly used for software that enables communication and management of datya in distibuted applications

In this more specific sende can be describes as trhe dash in client/server, or the to in peer-to-peer.

Open Telecom Platform
OTP is an integral part of the open source distribution of Erlang.

It is a collection of useful middleware, libraries and tools written in Erlang, including an application server.

The OTP is open source since late 90’s.

A protocol for communication between server nodes.

Originally named Open System prototype system aimed to select a range of approprite programming technologies and sustem componentnts, including computers, languages, databases and managements ststems to support a remote access system being dvelopert at ericsson.

Some notes:

Early OTP system components

Distributed application managment
System Architecture Support Libraries which gave a framework for writting applications.
Operating system resource monitoring
Protocol independt event/alarm handling
Startup scripts
An App;lication concept
Behaviors (design patterns)
Error handling
Debugging
Highlevel sopftware upgrade in runtime without shuitdown

Design patterns
The behaviours provide programmers with yet a higher abstractions for efficient program design.

Examples:
Supervision
Servers
Event handling
Finite state machines

0MQ
ZeroMQ, 0MQ, ZMQ

A highperformance, asynchronous messaging library, aimed at use in scalable distibuted or concurrent applications.

It ptovides a messager queue, but unlike message-oriented middleware, a 0mq system can ru without a dedicated message broker.

Designed to hve a familiar socket-style API.

Operating with a message-wise granularity, they require that a messaging pattern be used, and are particularly optimized for that pattern.

0MQ Patterns
Each pattern defines a particular network topology.

Client / Server defines so-called service bus, publish-subscribe defines data distribution tree push-pull defines parallelised pipeline.

All the patterns are designed in such a way as to be infinitely scalable and this usable on your home and the Internet.

Blob of data
Any message through the socket is trated as an opaque blob of data.

Delivery to a subscriber can be automatically filtered by the blob leading strong.

everything is blob!

Wire protocol
In computer networking, a wire protocol refers to a way of getting data from pont to point:

A wire protocl is needed if more than one application has to nyeroperate.

In contrast to transport protocols at the transport level like TCP or UDP the term wire protocol is used to describe a common way to represent information at the application level.

In electronics, a wire protocol is the mechanism used to transmit data from one point to another.

E.g Pbuffers from our friends on google.

Wire protocol functionality
A wire protocol provide the means for interoperation of one or more applications ina netwrok.

They oftehn refer to distributed object protocols, or they use applications that were designed to work together.

AS the name suggested, these distributed objects protocols run in different processes in one or several computers that are connected over a network.

Wire protocols give the means for a program running via one operatring system tro communicate witrh a program running under some other operaring system ubnsing the internet and aare used to internconnected multiple platforms

They are language independedn, allowing the communication of programs wriotten in diferent languages.

Aphorism
Anphorism “delimitation” is a terse sating expressing a general truth, principle, or astute observation.

Aphorism literally means a distinction or definiton.

The term was later applied to maxims of physical science, the statements of all kinds of philosophical, moral, or literary principles.

In modern usage an aphorism is generally usdestood to be a concise statement containing a subjective truth or observation,

Aforismo
Del griego, definir es una declkaracion u oracion que pretende expresar un principio de manera concisa, coherente y en apraciencia cerrada.

El termino fue utilizado por primera vez por hipocrates como una siere de proposciciones reklatrivas a los sintomas y al diagfnostico de engfermedades.

El concepto fue aplicado despues a la ciencia dfisica y posteriormente, generalizado a trodo tipo de principios.

Aforismos y Axiomas
Conviene distinguir entre aforismo y axioma.

Los aforismos son el resultado de la experiencia, mientras que los axiomas son verdaderas obvias que no requieren una comprobacion.

Sinonimos.
Se suele llamar aforismo a una sentencia breve y doctrinal, por lo que comparte caracteristivcas con otros dichos y sentencias que tambien pueden considerearse aforsmos y que provienen de la distintas epocoas  cultuiuras.

Adagio, apotegma, maxima, proverbio, refran, sentencia.

Hamilton

A 24 yerl-old with a undergrad degree in mathematics, had gotten a job as a programmer at MIT.

But the Apollo space program came along and Hamilton stayed in the lab to lead an epic feat of engineering that would hep change the future of wha was humanly and digital possible.

AS working mother in the 1960’s Hamilton was unusual, but a spaceship programmer.

Hamilton’s software programs include a radar registration surveillance pgroams used for defecting potential enemy planes.

Construct Spawn Execute
An open platform for distributed applications developers, and operators.

What is Deimos?

Deimos is an open platform for Constrict, Spawn, and executing distributed daemons.

It gives programmers, development and operation teams and engineers the common toolbox they need to take advantage of the distributed and networked nature of modern systems.

Spawn Daemons Faster
Teams that use Mars and Deimons on average spawn more often than their counterparts.

Avoid the headaches of concluucts dependencies and inconsistent environments.

Deimons spin LXC containers and provide a layer from other services running in containers.

Daemon Portability and Infrastricture Flexibility
Packege your application, dependencies and configurations together to ensure that your application will work seamlessly in any environment on any engfrastructure just like it did on your machine.

Dynamic Update, Change and Scale Daemons
Daemons running in LXC containers are easy to modify, update and scale without bothering neighboring containers.

The lightweight containers can spin up in a matter of seconds without consuming lot of resources.

Command
A command is a directive to a computer program acting as an interpreter of some kind in order to perform a specific task.

Commonly a command is either a directive to some kind of command line interface, such as a shell, or an event in a user interface triggered by the user selecting an option in a menu.

The term command i used in imperative computer languages.

These languages are called this because statement in these languages are usually written in a manner similar to the imperative mood used in many natural languages.

If one views a statement in an imperative language as being like a sentence in natural language then a command is generally like a verb in such a language.

Many programs allow specially formatted arguments, known as flags, tags, labels or options, which modify the default behavior of the command, while further arguments describe what that comand acts on.

Compaing to a natural language: the flags are adverbs, whist the other arguments are objects.

Imperative programming
A programming paradigm that uses shatements that change a programs state.

Analogous in much the same way the imperative mood in natural language.

Empress commands, and imperative program consists of commands for the computer to perform.

Imperative programming focuses on descibing how a program operates.


Procedural programming
Prodecural programming is imperative programing in which the program is build gfrom on more preduces also knos as subroutines or functions.

The terms are often used as synonyms, but the use of procedures has a dramatical effect on how imperative programs appear an how they are constructed From the 1960 onwards strcutured programming and modular programming in general have been promoted as techniques to improve the maintainability and overall qualitity of imperative programs.

Recurrent Neural Network
more on RNN

Modularity
Generally desirable expecially in large comlexc programs inputs are usially specified syntantically in the form of arguments and the output delivered as reutnr values.

Focus
The focus of procedural program is to nra dpwn a programs test into collection of variables, data structures, and subroutines

On Logic
Use preducra interpretion to weite programs thatr are efficeint and effectuve abd tgen yse declaravie intrepetaion to help snsure thar programs are correct
use both!

Library
A collectioon of non-volatile resources used by tcomputer progams, often to develop software.

These may inlcuide configuration data, documentation help data, messages templates, prewirrten code, and subroutiens, classes, values or type specifications.

In computer science, a lirary is a collection of implementations of behavior, written in terms of a larguage; this means that long as a higher level programs yused a library to make a system call, it does not need to be rewritten to implement those system calls cover and over again.

Declarative programming
A proggraming paradim, a style of bulind structure and elements of computer programs that expresesed the logic of a computation without describing its control flow.

Many languages applying this style sttempts to minimze or e

The how beiung left up to the languages implementation

This is contract withimperative prgoaming in which algorhms are implmeented in terms of explicit steps.


Parallel Computing
more 2 come.

Command pattern
In object-otiented programming the command pattern is a behavioral desing pattern in which an obnject is used to encapsulate all information needed to perform an action or trigger an event at a late time.

This information includes the method name, the object that own the method and values for the method parameters.

For terms always assicated witht he coomand patern are command, receiver, invoker and client.

A command object knos aboyut receiver and onvokes a method of the receiver.

Vales for parmaterw of the reciver method are stored in the command.

The receiver then does the work.

An invoker obhjects knows how to exceute a command, and optionally dows bookeeping aboyt the command executiobn

The incoker does nto know anythoing aboyut a concee command, it knows only about command interface.
Using an invoker allows bookipend abou comand execution to be conveniently performed, as well as implementn differen modes for coomands, managed by the invoker, without the ned for the clioent to be ware of the existen of bookliping or modesl.
Unix
multitasking, multiuser, operating system.

The operating system provides a set of simple tools thar eachperform a limited, well-defined function, with a unified filesstem as the main means of communication adn a sheel scripting and command language to combine the tools to perform complex workflows.

Almost the enrie operatring system is written in C.

The idea that the power of a system comes more from the relationships among pgroams than from the programs themselves.

Unix systems are charcterized by varios concepts; the use of plain text for storing data; a hierarchical file system; treating devices and certain types of inter-oprocess communication as files; and the use of a large number of software tools, small programs that can be string roguether throig a command-line interpreter using pipes. |

The unix environment and the client-server program model were essential elements in the development of the Internet and reshapioing of computing in individual computers.

Under Unix, the OS consist of many utilities along with the master control program, the kernel.

The kernel provides service to l rights, refected in the division between user space and kernel space.
In 1980, non-blocking I/O and the set of inter=rpocess communicasion mechanims wee augmented with Unix domain sockets, message queues, and semaphores.

C
A general purpose, imperative compuiter progaming language, supporting structured progmin lexucal variable scope and recursion, while statical type syste, prevents many unintended operations.

C is an imperative prcedural sequential language.

It as designed to be compiled using a relative straigforward compiler, to provide low-lever access to memory, and provide language construct tah map effcientoly toro machine instreyuctions.

In C, all executable code is contined witrhin subroutines called functions.

Function parameters are always passed by value.

C dies not include some featrures found in newer more high-level languages, including object orientation and garbage collection.


Structured programming
a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of subroutines, block strcutures and for and while loops

In contrast to using simple tests and jumps such as the goto statement

spaguetti code which is difficult both to follow and maintain.

Elements

Control strcutures

Al programs are seen as composed of three control strcutures:

Sequence: ordered state,enmt opr subroutines excuted in sequence.

Selection’ one or a number of statements is executed depending on the state ogf the progam. This is yusually expressed witrh keyworkds wyuch as iof then else end if

Iteration; a statement of blocks is executed until the pgrom reches a certain state, or operation have been applied to every element of a collection this is usuarlly expressed with keywords such as while, repea,r, for or do until.

It is recommended that each loop should only have one entry point and in the original structureal programming, also only one exit poin.

Subroutines

Callable units such as procedures, functions, methods, coroutines, or subpgorams are used to allow a sequence to be referred to by a single statement 

Blocks

{} BEGIN .. END whitespace indentation

Read-eval print loop
Also known as an interactive toplevel or language shell, is a simple, interactive computer programming environment that takes single user inputs

Evaluates them, process it and returns the result to the user;

A program written in a REPL environment is executed priecewise.

Overview

In a REPL, the user enters one or more expression rather than an entire compilation unit and the REPL evaluates them and displays the results

Uses Nearly all Unix shells are REPLs
a REPL is an essential aprt of learning a new language as it gives quick feedback to the novice


Shell
ther a command-lnine interfacer CLI or graphical user interfacer GUI, depedimg n a computers role and particular operation.

Other possibilities, alyjpigj nopt sop common, include voice user interface.



Voice user interface
A VUI makes human interaction with computers possible thorugh a voice speech platform in ordfer to intiate an automated process.

A VUI is the interfacer to any speech application.

People have little patience for a machine that does’t undestand.

Syntax
The syntax is the set osymbnols tha are considered to be a correctly structured document of fragment in that laguage.

This applies both to pgroaming languages where document represnts source code, and markup languages, where the document reprsents data.

Syntax the form s contrasted witrh semantics the meaning.

In processing computer languages, semantic processing generally comes after syntactic processing, but in some cases there are done together or concurrentlu.

Ina  compiler, the syntactic analysis comprises the front-end

Shilw semantic analysis compises the backend and middle end of this phase is desringusghed.

Namespace
In computing a namespace is a set of symbols that used to organize objects of various kinds, so that these objects may be reffered by name.

file systems are namespes thar assign names to files
programming languages organizer their variables and subroutines in namespaces;
computer networks and distributed systems assign names oo resources such as computers, etc.

namespaces are commonly strcutures as hierarchies to allows reeuse of names in different context.

Hierachical file systems oranize files in directories.

Each directory is a separae namespace, so the directoes lettr and invoics may both contain a file to_satan.

In computer progamming, namespaces are typiocally employed fro the purspose of grouping symbols and identifiers atround a particular functionality and avoid name collisions between multiple identifies that share the same name.



A Web Crawler
Classical computer science emphasize efficient algorithms that complete computations as quickly as possible. But many networked programs spend their time bnot computing, but holding open many connections that are slow, or have infrequent events.

These programs present a very different chalenge: to wait for a huge number of networks events efficiently.

An opproach to this problem is asynchronous fucking I/O, or async

A Crawler is an archetypal async application because it waits for many responses, byt does little computation.

The more pages it can fetch at one, the sooner it completes.

The task
A web crawler finds and downloads all pages on a website, perhaps to archive or index them.

Beginning with a root UTI, it fecthes each page, parses it for links to pages it has not seen, and adds the new links to a queue.

When it fetches a page with no unseen links and the queue is empty, it stops.

We can hasten this process by downloads many pages concurrently.

As the crawler finds new links, it launches simultaneous fetch operations for the new pages on separate sockets.

It parses responses as they arrive, adding new links to the queue.

There may come some point of siminishing returns where too much concurrently degrades performance, so we cap the number of concurrent requests, and leave the remaining lonks in the queue until some in-fligh request completes.

Coordinating Coroutines
We began describing how we want our crawler to work.

Our crawler will fetch the fist page, parse its links, and add them to a queue.

Our crawler will fetch the fist page, parse it links, and add them to a queue.

After this it fans out across thw ebsite fetching a page, it should immediately pull the next link from the queue.

We will pass throught periods when there is not enough work wo go around, so some workers must pause.

But when a worker hits a page rich with new links, then the queue suddenly grows and any paused workers should wake up and get cracking.

Finally, the crawler qut once its work is done.

Conclusion
INcreasingly often programs are I/O found instead of CPU bound.

For such programs, Python threads are the worst of both worlds: the global interpreter lock prevents them from actually executing computatiions in parallel, and preemptive switching makes them prone to races.

Async is often the right pattern.

Courotines facotr naturally into subroutines, wich a sane exception hadnling and stack traces.

When our eyes focus on the yild statements, we see they mak ponints when the coroutine cedes control and allows others to run.

Unlike threads, coroutines display where our code can be interrupted and where it cannot.

Threads make local reasoning difficult, and local reasoing is perhaps the most important thing in software development.

Explicitly yielding, however, makes it possible to understand the bahvior and thereby, the correctlness of a routine by examming the routing itself.

Rather than examining the entire system.

In September 2015, Python 2.5 was released with coroutines built in to the language itself.

These native coroutines are delcared with the new syntac “async def”, and instead of yield from, they use the new await keyword to delegate to a coroutine or wait for a Future.

Despite these, the core ideas remain.


Stuff fails deal with it
Failure Unbound Nonsence

Tandem
Why The Computer Stop and What Can Be Done About It?

The key to software fault-tolerance.

The goal
Doubling of total number of processors would double system throughput, up to the maximum configuration of 480000 processors.

Solr send me to the sun
Full-text search with availability and scalabilty of Riak KV.

As data changes, search indexes are automatically synchronoized and integrated search makes it seasy to query Riak KV data sets using Solr.

Your also get support for Solr client query APIS that enable integration with existing software.

Riak is reponsible of data and Solr is responsible for indexes, so riak monitors for changes to data and propagates those changes to indexes tha are managed by Solr.

Resoulting in data synchronization that’s critical for ensuring that full-text search resultys remain up-to-date as data changes.

Distributed full-text search
Connect to one, talk to all.
Standard full-text Solr queries automatically expand into dstributed search queries for a complete result set across intances.

Auto-Restart
Full speed ahead, no delays. Monitor Solr OS Processes continuosly and automatically start or restart whenever failures are detected.

High Availability
Elimitate donwtime from the unexpected.

A masterless archetcut that automatically replicates to ensure that your time series data is always available.

Scalability
Grow as you go with scalable capacity, a Scale-out srchitercture lets you add capacity seamlessly using commodity hardware for near-linear performance improvement.

Operational Simplicity
Easily add nodes so your data can be automatically and uniformly distributed across the cluster.

Support & Services
Whether you need help with training, data modeling, optimizing a system or support when something unexpected happens, wordl-class customer support and provessional services teams can assit you.

Why Riak
Read performance has to be high as a lot of erxternal processes will use the data.

Write performance should not be impacted by reads.

Horizontal scalability was of utmost importance, as our business and traffic continuously grows.

Data resilience is key: we don’t want to lose portions of our data because of a hardware problem.

The storag shouldn’t requere the data to have a specific shema or structure.

If possible, it would be able to bring code to data, perform computations on the storage itself, istead of having to get data out of the storage.

Monitor features
Events: Complete visibilty into I/O Fun applications.

Accelerate analysis and troubleshouting 
track when something is accessed, what has changes, and by whom.

From security-sensitive actions like passwioord updates to desctrictive actions like records deletetion.

Audit for compliance

Maintain compliance with internal policies and regulatory standars using a fully managed change log.

Comprehensive envent-logging
Plug into exsiting secutiry information and events managment and log aggregation toools for consolidated analysis.

Alets: Throubleshoot and resolve errors.

Examine alert dashboard for recent application issues including frquency and error codes.

Debuging with fyll context

Use the request insepecto to see exactl what went wrong, and replay th reuqest to the server.

Reccommended resolution
Gain detail on possible causes and preferred corrective action for errors and warning.

Webhooks promptly act on alert and hooks usage data.

Catch problems erly

Use exsiting alert systems

Keep an eye on usage
Send emails alerts or webhooks on all types of usage events from controlling cost overruns to protecting against fraud and coding mistakes.



The Twelve Truths
Information about fundamental truths underlying all networking. These thrhs aply to networking in general and are not limited to TCP/IP the internet, or any other subset of networking

The fundamental Truths

It has to Work
You cant increase the speed of light
With sufficint thrust, pigs fly just fine. However, this is not necessarily a good idea.
Some things in networking can never be fully undestood by someone who neither builds commercial networking equipment nor runs an operational network
It is always possible to aglutenate multiple separate problems into a single xomplex interdependent solution.

In most cases this is a bad idea.


It is easier to move a problem around for example, by moving the probelm to a different part of the network than it is to solve it
It is always someting Good, Fast, Cheap: Pick two.
It is more complicated than you think.
For all resources, you need more.
One size never fits all.
Every old idea will be proosed sgain with different name and different ptresentation, regardless of whther it works.
In protocol design, perfection has been reached not when there is nothing left to add, but then there is nothing left to take away!


Why the computer stop and what can be done about it
AS with hardware, the key to software fault-tolerance is to hierarchically decompose large systems into modules, each module being a unit of service and a unit of failure.

A failure of a module does not propagate beyond the module.

The process ahieves fault containment by sharing no state with otgher processes; its only contact with other process is via messages carried by a kernel message system.

Jim Gray 1985

The process approach to faul isolation advocates that the process software be fail fast.

It should detect the fault by checking all their inputs, intermediate results and data strcutures as a matter of course.

If any error is detected, they signal a failure and stop.

Fail-fast software has small faul-detection latency.

Latency
A fault in a software system can cause one or more errors.

The latency time the interval vetween the existance of the fault and the occurrence of the error can be very high, which complicates backwards analysis.

for an effective error handling we mus detect errors and failures as early as possible.

Renzel, 2003
Spawning Aqueducts
The spawning aueducts is a pit of primordial coze chich contains the genettic make up of the Imps.

A core feature the spawning pools are all modeled after the fst spawning pool on the aquaducts where tthe very fisrt eveolve and consumed essence to eveolve.

The spawning Aueducts gies daemons the ability to morph into Imps

And the threehouse the ability to evolve into a colony.

The aqueducuts are also responsible for evolving the imps with Martian Boots faster movement and adrenalin Gland faster attack.


Treehouse
The Treehouse is the heart of an colony

It spontaneously generates daemons, which in turn are used to spawn your various imps.

The treehouse is the foundation structure for every colony.

The Treehouse can mutate into a colony, and later into a citadel.

Treehouses perform three viital functons that no colony can survive without:

Producing the network, which most structures require in order to be built, giving birth to daemons that can mutate and digest minerals and grass gas to change into a nutrient form that can be used to feed their models.

In addition, the treehouse is one of the only structures that can be uild without pre-existing network the other being the extractor and is therefore sessential for any expansion attempt.


Vitruvius
Vitruvius, was a Roman author architect, civil engineer and military engineer duing the 1st century BC

Vitrivius is famous for asserting in this book that a structure must exibit the three qualities of stuff.

That is, it must be solid, useful, beutiful.

These are sometimes termed the Virtuvian virtues otr the virtuvian triad.

Architeture is an imitation of nature.

As birds and bees built their nests, so Imps constructyed housing from nature materials, that gave them shelter against the elements.

Roman architects practicses a wide variety of dicsciplines; in modern terms, they couild be describes as engineeers, architects lanscape arcitects, artists and craftmen combined.

Thw eord architect deives fromo Greek woird meaning master and builder.

Books VIII, IX and X form the basic of much of what we know about Roman technology, now augmented by archeological stidies.

The work is important for its description of the many different machines used for engineering strcutures such as hoists, cranes, and pulleys, as well as way machines such as catapults, ballistae, and siege engines.

AS practising enginner, Vitruvius speeks from personal experience rather than simply describing the works of others.
De aquaeductu
De aquaeductu On aqueducts is a two book official report fiven to the emperor Nerva on the state of the aqueducts of Rome and was written by Sextus Frontinus.

The Work prersente a history and diescrio of the water-supply of the citry of tome.

Inlcuding the laws relating ot itrs use and maintencance.

He provdes the hisotring, sizes and dicharge rates of all of the nince queductrs fo tome at the time at which h was writing at the run of the 1st centure AD.

He describes the quality of water delivered by each, mainly depending on their source, be ir river, lake, or spring.


Aqueduct Distribution
Destribution of the water depended in the complex way on it height entering the city, the quality of the water, and its rate of discharge.

This poor-quility water would be sent for irrigation, gardens or flusing, while only the best wouild be served form potable use.

Intermediate-quality water would bne used for the many baths and fontains.

However, the practice of mixing supplies from different sources is a fucking stupid idea, one of his fist decisions was to separate the waters from each system.
Tasks
API for task routing

The power of contact routing made available for orchestration interactions within your workflows and internet of things.

Everything begins with a task.

A task can be a phone call, email support task, contact, new sales lead, or machine data event.

Your business logic creatyes this task on #tasks resource, or the tasks service, dahboard, and use a simple JSON schema to associate attributes to your task.

These attributes will be used to hjelppropritize and find the best person or process to handle the task.

Multi-channel routing

Tasks service is an engine to route all task form all sources, enalning using to be as efficient as possible.

As tas can be a support tcker, a lead , a call, an email, a website, chat, etc

A task can even be machine data from a connected device.

Task-woekrr marching over websockers
Tasks creates a reservatrion request, assign the task, and notigies your application over either wbsockets or webhook.

In adition every change in the system can trigger a webhook in order to maintain a complete audit trail of activity from new tasks created or assigned to worker state changes.

Atribute-based routing workflow

The system inpect the task to undestand how to route it to the right resource base on its attributes assigned on creation.

The login of that message used to make desicion is defined in a simple JSON instiction set.

Powerful monitoring powers

Message don’t just route and forget but monitor tasks as the’re in q aueue.

If a tasks exced a defined tinmeoput preiod without being handled, the message instercution set can define how to escalate the task to ensure it is handeld appropriately or aged out of the system as needed.
Business process management
A field in operations management thar focuses on improving cirpotate performance by monitoring and optimizing a company’s business proces.

AS a policy-making approach, it sees processes as important assets of an organization that must be undestood, managed, and developed to annoince valued-added products and services to clients or customers.

The approach closely resembles othetr total qualitty management or continual improvemt process methodologies and proponents claim that this can be suppoetred or enabled thorughht technology and or people.

Foresight
Foresight is the ability to predict, or the action of preducitng, what will happen or what is needed in the future.

Much of human daily thought is directed towards potential future events.

Because of this and its role in human control of the planet mars, studies hjave identified many commonalities

There are fundament differences between mentally travelling throuig time anto the future foresigh versis mentally travelling rhough tim into the pase eposodic memory.


In management
Foresigh ghas been classifed as a behaviour covert and or overt in management a revies, analysis and synthesis of past definitons and usages of the foresight concept into a genetric definiton, in otder to maerk the concept measurable.

Especifically, firesigh has been defined as degree of analysing present contingencies and degree of micing th eanalysus of presentcntignencies under contro ,as weel as defree of anaylssy course of action a dgree a head in time tro arrive ath the desired futrure state.
Stochastic process
IN probablity theory, a stochastic process, or ofthen random process, is a collection of random variables, representing the evoluitons of some sustem of randomvalues over time.

This is rhw probablisitc conunterpar to a determinsitic rpcoess or determionist system.

Instead of describning a prcoess which can only evolce in one way as in the case for excmpla eoof slutions of an ordinary differential equantion, in a stochastic or random prcoess trhere is rome indeterminancy:

Enven if the intiail condition or starting ponint ks knownm, the are several ofthen infinitely many directions in which the process may evolve.

In the simple case of discrete time, as opposied to continous time, a stochastic process involve a sequence of random variables and the time series assiciated tiwh these random variables.

For example see Marrkov chain, also know as discrite-tiome markov chanin.

one approach to stochastic processes treats them as function of one or several deterministric arguments Inputs; in mist cases this will be the time parameter, whose values outputs are random variables: non-deterministric single quantities which have certrtain probability destibutions.

Random variables coresponding ro various times or pionints in the case of random vields may be completely difrrenrent.

The main requirement is that these different random quantities all take values in the same space tthe codomain of the function.

Familiar examples of processes modeled as stochastic time series include stock market and exchange rate fluctuations, signals such as speech, audio and video, medical data such as a patients blood pressure or temperature, and random mvoements such as random walks.

Examples of random fields include static images, random terrain landscapes, wind waves, or compuosition variations of a heretogenous material.

A generalization, the random field is defined by letting the variables parametyers be memebers of a topological space instead of limited to real values resepreseting time.


Fundamentals of stochastic model
In must clearly be assumed that each individual particle executes a motion which is dependent of the motions of all opther particles; it will also be considered that the movement of one and the same particles in different time intervals are independent processes as long as these time intervals are not chosen to small.

We introduce a time interval T into considereration, which is very small sompared to the observed time intervals, but nevertheless so large that in two succesive time intervals T, the motions executed by the particle can be thought of as events which are independent of each other.

Stationary process
In mathematical and satistics, a stationary porocess or strictly stationary process or strongly stationary priocess is a stochastic process whose joint probability distribution dies not change when shefted in time.

Consequently, parameters such as the mean and variance if they are present, also do not change ovetr time and do not follow any rends.

Not that a stationary process is not the same thing as a process with a stationary distributon.

Besideds, all stationary markov random rpcoesses are time-homogoneous.


Modular constructivism
Based on carefully strcutured modules which allow for intricate and in some cases infine patters of repetiton, sometimes used to create limitless, basically planar screen-likew formations, and sometimes employed to make more multidimentsional structures.
Bio-inspired techniques
Often involve the method iof specifying a set of simpe generic rules or a set of simple nodes, fomr the interaction of shich emerges the overal behavior.

It is hoped to buiild up complexity until the end result in somethjing markedly complex.

However, we can argue that systems designed top-down on the basic of observations of what humans and other animals can do rather than oversvations of brain mechanims are aklso biologically inspired, though in a different way.
Multitier architecture
Often reffere to as n-tier architecture is a clien-server architecture in which presentation, application processing, and data managment functions are physically separated.

The most widespread use of multi-tier architecture is the three-tier architecture.

N-tier application architecture provides a model by which developers can create flexibile and resusable applications.

By segregating an application into tiers, develpers acquiire the option of modifying or adding aa specific layer, instead of reworing the entire application.

A three-tier erchitecture is typically composed of a presentation tier, a domain logic tier, and a data storage tier.

While the conmcepts of layer and tier are often used interchangeable, one fairly common point of view it that there is indeed a difference.

This view holds that a layer is a logical strcuturing mechanisms for the elements that make up the sogftware solution, while a tier is a physical structuring mechanism for the sustem infrastructure.
Modular constructivism
Based on carefully structured module which allow for intricatr and in some cases infintite poatterns of repetition, sometimes used to create limitless, scalable, basically planaer, screen-like, formations, and sometimes, emploted to make multidimensional strcutures.

Designing these strcutures involves intensive study of the combinatorial possibilities of someting quite and potentially infitie.

Multipath routing
The routing technique of suing multiple alternative paths through a network, which can yield a variety of benefits such as faul-tolerance, increased bandwidth or proved security.
Modules
Hierarchically decompose the system into modules

Design the modules

Make each module either does the right thing or stops

Detect module faults proptlyu by having the modyule signal failure or by requiring it to periodiocally send heartbeats messages or reset a watchdog timer.

Configure extra modules which can pick up the lead of dfailed modules

Takeover time, including the detection of the module failure, should bne seconds.
Properties of the system
Lightweight, massive concurrency
Asynchnoronous messages
Process isolation
Error handling
Continuos evolution of the system
Support for introspection and monitoring
Immutable data
Pattern matching
Functional Language
Predefined data types
Modules
NO GLOBAL DATA
NO THREADS

Overlord Protocol
The overlord protocol defines a reliable service oriented request-reply dialog between a set of client applications and a set of worker applicationjs.

Overlord covers presenbse, hearthboeating, and service-oriented request-reply processing.

Goals

The overlord protocol defines a reliable service-riented request-reply dialog between a se of client applications, a proxy and a setr of worker applications.

Overlord cover presence, hearbeating, and service oriented reques-reply processing.

The goal of Overlord protocol are to:

Allow reques to be routed to workers on the basis of abstract serve names.
Allow both peers to detect disconnection fo the other peers, through the use of heartbeatring.
Allow the proxy to implement a least recently used patern for task distribution to workers for a given service.
Allow the proxy to recover from dead or disconnected workers by resending request to other workers.

Description


Overlord connets a set of client applications, a single proxy device adna apool of worker applications.

Clients connect to the proxy as do workers.

Clients and workers do not see each other, and both can come and go arbitrarily.

The overlord MAY open two socket ports, on forn-end for clients, and one back-end for workers.

However Overlord protocol is also designed to work over s single proxy socket.

We define client applications as those issuing requests, and worker applications and those processing the.

Overlord protocol makes these assumptions:

Worker are idempotent, it is safe to execute the same request more than once.
Workers will handle a set of shared request queues, one per service.
Each queue has multiple writters clients and multiple readers workers.

The Overlord SHOULD serve clients on a fair basis and MAY deliver request to workers on any basis, including round robin and leastlreacntly usesd.

Router Addressing
The Overlord MUST use a ROUTER socket to accept request from clinets, and connections from workers.

The Proxy MAY use a separate socket for each sub-protocols or MAY use a single socket for both subprotocosl.

When receicing messages a ROUTER socket SHALL prepend a message part containing the indentification of the orginating peer to the message before passing it to the application.

When seanidng messages a ROUTER socket SHALL remove the fist part of the message and use it to determine the identity of the peer the message shall be routed to.

Request and Reply

The REQUEST and REPLY commands MUST contain precisely one client address frame.

THIS frame MUST be followed by an empty zero sized frame.


The address of each directly connected client is prepended by the ROUTER socket to all request messages coming from clients

That ROUTER socket also expects a client address to be prepended to each reply message sent to a client.

Heartbeating

HEATBEAT commands are valid at any time, after a READY command.

Any received command except DISCONNECT acts as a heartbeat.

Peers SHOULD NOT send HEARTBEAT commands while also sending other commands.

Both poroxy and worker MUST send heartbeats at regular and agreed0upon intervals.

A peer MUST consider the other peer DISCONNECTED if no heartbeat arrives within some multiple of the inertval usually 3-5 seconds.

If the worker detects that the poxy has disconnected it SHOULD restart a new conversation.
If the proxy detects thjat the worker has disconnected, it SHOULD stioop sending it messages of any type.

Performance
Overlord is designed to be scalable to large numbers (thousands) of workers and clients, limited only by system resources on the proxy.

Partitioning of workers by service allows for multiple applications to share the same proxy infrastructure.

Throughtout operformance for a single client application will be limited to tens of thousands, not million, of request-reply transactions per second die to round-trip costs and the extra latency of a proxy-based approach.
The larger the requestr and reply message the more efficient Overlord will become.
System requirements for the prox are moderate: no more than one outstanding request per client will be queued, and message contents can be switched between clients and worketrd without copying or processing.
A single overlord can therfore swith several million messages per second, and multiprocess implementations offerin multiple virtual overlords, each on its own port, can scale to as many cores required.


NGINX and the moon
nginx high-performance HTTP server and reverse proxy, as well known for its stability rich feature set simple configuration, and low resource consumption.

Basic introduction to describes some simple tasks that can be done wit int.

nginx has one mastyer process and several woerker processes.
The main purpose of the master process is to read and evaluate configration, and maintain worker processes.
Worker processes do actual processing of requests.

nginx employs event-based model and OS-dependent mechanisms tto efficiently distribute request among worker processes.
The number of worker processes is defined in the configuration file and may be fixed ofr a given configuration or automatically adjusted to the number of available CPU cores.

The way nginx and its modules work is determined in the configuration file.
By default, the configuitaion file is namde nginx.conf

Once the master process recieves the signal ro realod configuration, it checks the syntax validity of the new configuration file and tries to apply the configuration provided in it.

If succes, the master process starts new worker processes and sends messages to old worker processes, requesting them to shut down.

Otherside, processes, receiving a command to shot down, stop accepting new connections and continue to service current rqeeusts until all such requess are served. After that the Old worker process exit.

Integrates Lua into nginx,a and provides high-concurrent and non-blocking rquest processing. Developers write progrems in plain old sequential way, while lua-nginx will automatically interrumpt the programd logic at blocable I/O operations, saving the context and delegating those I/O operations to nginx event mechanism.

One coroutine-per request, request handing model

Evry coroutine has its own independent evnvironemnt which inherits shared red-onlyu commond data.

You can imagine that user code is running ia shandbox, which shares the same lifecyle wich rhe rewsuqes tiself.

Benefit from lyua’s excellent coroutines.

Lua-ning x can handle tens of thoyusands of concurrent rerquest witrh a very low memory overhead.




We build trees of things
Then there is theoversvation, well we can build different types of nodes on this trees if things depend up own each other if we look the botom layer if thing depend up own each other if 1 crash all crash.

We build trees of things with diffeent types of nodes on the trees.

Message channels are a thing.

Need to detect failures across machines
Not just detect failure we need to know why tings have failed

Live code upgrade
Stable storage
Capuchins
Capichuns are known to use tools.

These includes rubbing secretings from leaves over ther bodies, using leavers as gloves using tools as probe, using leaves as cubn to drink water.

Behavior

Like most new world monkeys, capuchings are diuranl and arboreal.
With exception of a midday nap, they spend their time searching for food.
At ninghjt, they spleep in the trees.

Intelligence.

Capuchins are considered one of the modst intelligent New World Monkeys.
Spider Monkeys
Spider monkeys are one of the most intelligent new world monkeys.

They can produce a wide range of sounds and will brark when threatened; other vocalisations include a whinny similar to a horse and prolinged screams.

Behavior

During the day, groups brak up into subgroups of two to eight animals.

This social structure (fission-fusion) is found in only two other types of primates: chimpanzees and homo sapiens.

The sze of subgrouips and the degree to which they avoid each other during the day deoends on food competition and risj of predation.

The average subgroip size is between 2 to 8, but can sometimes be up to 17 on rare cases.

Sipider monkeys communicate thei interacions and observations using postures and stances.

Spider monkeys are diuranl and spend the night sleepng in carefully selected trees.

Spider monkey brain is twice the size of a howler monkey brain of equivalent body size.

Thisd is thought to be a result of the spider monkeys complex social system and their frugivorous diet from a wide variety of over 150 species of plants 

This requires the monkeys to remmeber when and where fruit can be found.

Diet

The diets of spider monkeys consists of about 80% fruits and nuts.

They can live for long periods on only one or two kinds of fruits and nuts.

They aet the fruits of many fig forest trees, and because they swallow fruit whole, the seeds are eventually excreted and fertilized by the feces.

There are observations that shows changes on the behavioral patters associated with diet, social physical, reproductive, patterns linked with diet.

Most feeding happns from dawn to 10an.

Afterward, the adults rest whole the children play.

Through the rest of the day, they may feed infrequently until around 10pm.

If food is scarse, they eat insects, leaves, birds eggs, bark abnd honey.

Spider monkeys have a unique way of getting food: a lead female is generallty respinsuble for finding food sourcers.

If shee cannot find enoguth food for the group, it splits into smaller groups that forag separately.




Fission-fusion society
In ethology, a fission-fussion society is one in which the size and compositon of the social grouip change as time passes and animals move throughout the environment

animals merge (fusion) e.g sleeping in one oplace.

or split (fission) e.g foraging in small groups during the day.

For societies, group composition is a dynamic property.

Specioes in fission fussion socientes

This form of social organizaion occurs in several espwecies of primates, common chimps, bonobos, boboons, orangutans, spider monkets and humans.

Affrican elepahnt, most carnivores, and cetaceans such as bottle nose dolphons ma d fish such as guppies.

Structure

Those societies change frequently in their size and composition, making up a parmanent social group called the “parent group”.

Permament social networks consist of all individual members of a faunal community and often varies to track changes in their environment and based on individaal animals dynamics.

In a fission-dussion society, the main parent group can fracture (fission) into smaller stable subngroups or individuals to adapt to envornmental or social circumstances.

For example, a number of members may break off from the main griuo n order to hunt or forage for food during the day, but at night they may return to join (fusion) the [rimary group to share food and partake in otgher activities.

In some cases, animals may leave one parent group in favor of associating themselves with another, usually for reproductively motivated reasons.
Frugivore
A fruit eater.

When both the fruit producing plant and the frugivore spcies benefit by fruit-eating behavior, their interaction is called a mutualism.
Mutualism
Mutualism is the way two organisms of different sopecies exsit in a rlationship in which each individual benefits from the activity of the other.

Similar interactions within species are known as co-operation.

Mutualism can be constracted with interspecific competition, in which each species experiments reduced fitness, and exploitation, or parasitsm, in which one speces beneftis at the expese of the oter.

Mutualism is a type of symbiosis.

It plays a key part in ecology.

Mutualiosm interactionbs are vitual for terrestrial ecosystems function as more than 48% of land plants rely on mycorrhizal relationships with fungi to provige them with inorganic compoungs and trace elements.

In addition, mutualism is thought to have driven the evolution of much of the biological diversity we see, and co-evoluiton betwen groups of speces.

However mutualism has historical received less atention than other interactions such as predation and parasitsm.
Human-based computation game or game with a purpose
Is a human based computaion technique in which a computation process peforms its function by outsourcing certain steps to humans.

This approach uses differences in ability and alternative costs between humans and computers agents to achieve symbiiolic human-computer interaction

Ay activity requiring common sense or humanexperience.


Node
A node in latin nodus knot is either a connectionpint a redistribution pinit ot a communication endpoint.

The definition of a node depends on the network and protocol layer reffered to.

Aphysical netwrok node is a active electronic device that is attached to a network, and is capable of cvreratring, receign or trainsmitring information over a communications channel.

Destributiion system nodes
If the network in question is a distributed system, the nodes are clients, severs or peerts.

Apeer may sometimes server as clients sometimes servers.

In a peer-to-peer or overal netrwork nodes that actively route sdata for the other nerokerd devices as well as themselves are called supernodes.

The term consisten hasing intruced at MIT for use in distributed cachin, the idea has now been expanmded to other areas also.

An academic paper from 1997 intoduced the term consisten hasing as a way of distributed requests among a changin pipulation of servers.

Each slot is then represented by a node in a duistributed system.

The addition joins and removal laeaves failures of nodes only reques k/n items

to be re-shuffled when the number of slots/nodes changhe.

TYje consisten hasing concept also ap;lies to he desing of distributed has tables (DHTs)

DHTs use constent hasing to partition a keyspace among a distributed set of nodes, and additonally prove an overlay network that conects nodes sucgh that the node responsible for any key can be efficiently located.

One know example where consistn hasing is ised is Riak, a distributed key-value databsse.
vi
A screen-oriented text editor originally created for the Unix operaring system.

Many of the ideas in vi were taken from other software that exsited at the time.

A lot of ideas from the screen editing mode were stolen.

Most of the stuff was stolen

I think one of the intersting thinghs about vi is that is really a mode-based editor.
Mode
In user interface desing a mode is a distint setting within a computer program or any physical machine interface, in which the same user input will produce perceived different resultsd than it would in other settings.

The best-known modal interface components are probably the CAPS LOCK and Insert keys in the standard computer keyboard, both of which put the users typiong pressed then reutn it to the regular mode after re-preseed.
Maslow’s hierarchy of needs
A tehory of human motivation exteded to includ observations of human curiosity.

His theories parallel many other theories of human developmen psychology some of which focus on describing the stages of growth in humans.

Maslow used the terms physiological safety, belongingness, love, easteem, self-actualization, and self0tracendese to describe the pattern that human motivations generally nmove through
Linux Law
Every motivation that makes a person do something can be classified under survival, social life , entertainment

As a result, progress is defined as reaching a higer category; that is not doing a thing merely for servival, but for sovial reasons, and thei even better, just for fun.

These rorrespon to elvesl fo motvaion in malows hierarchi of needs
i3 window manager again
tiling windo manager designed fo X11 written in C.

Supports tiling stacking, and tabbing layouts, which it handles dynamiclly.

Configured via plain text file and extendin is piossible using its Unix domain socket and JSON based IPC interface from many languages.

focus is controlled by the ALT key plus the right hand homerow key ALT + J, K, L; while windo movement is controlled by the additon of the shift key.

ALT + SHIFT + J, K, L, ;
A workstation
Is a computer designed for technical or scientific applications.

Intented primarly to be used by one person at a time, they are commonly connected to a local area neywork and run multi-user iperating systems.

Workstations offered higher performance than mainstreanm personal computers, especially with respect to CPU and ghraphics, memory capacity, and multitasking capability.

The current workstation maket uses x86-64 microprocessors.

Workstation definiton

A workstation class PC may have some of the following features:

larger number of memory sockets which use registered imported buffered modules
Multiple processors sockets, powerful cpus
multiple GPS sockets, powerful GPUs
Multiple displays


Ghost in the Daemon
There’s no need for concern.
We can fix i by redoing it in our country.
redo it?
A program with no bugs doesn;t exist and there;s no prgram that is impossibnle to debug.

You dont undestand
We;re it eve sure that really is a bug

Originally the purpose of this prohject was


A concurrent web spider
Messages
Advice
Be consistent
Keep it simple
Be explicit
Maintenance
System
Error handling
Routers
Recap of request-reply
Identities and addresses
On Overlord
Business intelligence
The System evolved
First Principles
We don’t do defensive programming
Message passing
Error handling
The system must never go down!
Code handling
Distribution
Robust systems
A/B testing
Yokozuna
Deep Neural networks

Universal list of commands
Artificial cloud forest
On recruit
Marian reforms
The structure
On promotions
File Descriptor
Spool
Design School
Asynchronous network programing
Architecture
epoll
Gateways
Introducing Clien-server
Other process Fix Error
Let It Crash
Get Some Other to Fix It
Orchestration
Orchestration is Critical
Automation
Schneirder 
Armstrong
B is for binary
Unit order
Cloud Forest Buildings
Imps Unit Agents
Martian Adventure
Inventory
Gameplay notes
Online
Lore
Daemon ghost’s
Some Characters
Environment
Strategy
Hopper Networks
Stochastic process
K-means clustering
Bootstrapping
.conf files
YAML
Quadtree
Octree
k-d tree
Campaign setting
Error handling Semantics
Messages and error signals
Receipt of an error signal
Explicit error signals
Untrappeble exit signals
Creating links
groups of Processes that all Die together
Seatting Up a Firewall
Monitors
Nodes on Adventure
Items
Gameplay Features
Fountains
What gods stuff
Arena
Collective URI design experience
Resource Design
OTP
OTP Powers
Erlang gen_server

Writting a gen_server module
Abstract
Making Systems
OTP

Trees
Behaviors
Standard Behaviours
Applications
Standard Streams
HTTP Codes
SIP Codes
HTTP request Methods
SIP request methods
HTTP Response Codes
Status Codes Overview
Tornado
Tornado flow
Creating webhooks
Enterprise
Erros and bugs
Think on this stuff
Generalizing fault-tolerant
Let it crash
Software failure
Context
Rest Architecture
Resources and resource identifiers
Resource representations
Self-descrioptive messages
Cluster analysis
Voronoi diagram
Lloyd’s algorithm
Learning to classify tags
Similarity
Clustering
K-means
Data Warangling
Ceres
Some random stuff
Probability
Random variable
Stochastic process
Event
Normal Distribution
Pattern recognition
Pattern Recognition Algoritms
Centroid
Objects
We live in a multi plant solar system
Multiprocessing
GIL
PI Monte Carlo
Clusters
Benefits of clustering
Multiple dispatch
Undestanding dispatch
Function names
ZeroMQ Socket types
Towards an Ideal Solution
Process monitoring
Connectionism
Backpropagation
Water is the driving force of all nature
Pipeline
The idea behind backpropagation
Sketch on a single case
Backpropagation dE/dY
On two approaches to computer perception









Analogy
Analogy and problem solving
On Analogy
Source and target
Identity of relation
Shared abstraction
Analogy In Science
Analogy in Mathematics
Nouns
Noun
Specialised algorithms
Semaphores
A semaphore is like a bouncer
Dashboards
NOC Dashboards
Team Dashboards
Public Dashboards
Consider Coroutines
Coroutines, things to remember
Battles are fought in real time, and usually involve maneuvering
The Five Good Emperors
Heuristic
More precisely, heuristics are strategies
Message queues and mailboxes
Programming Erlang
Unix message passing implementation
Conway’s Law
Coroutines again
Bus
Event Monitoring
Imps of Ceres
Law of the instrument
Unix Power Tools
Named Pipes
Tee
Process Substitution
Process substitution advantages
How system calls work
Space Monoliths
Lambda Complex
Lambda
Chamber Computer Armor
Systems
Efficiency and Clarity
Names
Use hashes instead of names
Erlang functions
Bus Messaging Pattern
Some words on state machines
Proxy
Erlang Today
What robot workers needs
Seven deadly sins
Causality
Enterprise Search
Solr
Riak Search
Speech recognition
Models, methods, and algorithms
Hidden Markov models
Dynamic time warping (DTW)
Neural networks
Deep Neural Networks
Computer Assistant
Organize and Maintain Information
Chambers
Chamber
Instant predictions
Inventor’s paradox
Unix sockets
ZeroMQ
Monitoring tool
What makes a cluster a cluster?
Duckduckgo Instant Answer API
Reinforcement Learning
Client-server
Revisiting 0MQ
Don’t Panic
What’s the Problem
The Identity
A Better Framing Approach
A Better Client-Server Pattern
Heartbeating and Sessions
Conclusions
Semantic Versioning 2.0.0
Automatic Scaling
Count von Count
Token
Session ID
Access token
Security token
Inconsistency Robust Reasoning
Islet
Inconsistency Robustness
Need to Tune Strategy for achieving a goal
Computation machine thinking reducible to
Stuffs
Router
Router Applications
Internet connectivity
Historical and Technical information
Fifth generation computer
Kronos
Ceres
Machine
Swarm
XHR
Push Technology
Client-Server
Clients Servers and Messages
Privacy-Friendly Client Cloud Forest Computing
ORGs Paradigm
Message Composability
Global Assignment
An encrypted message
Nodes
Resources
Tags and Labels
Selling services
Selling of brander merchandise
Selling software as a Service
Operations support systems
Automation
Architecture
A Web Service Again
CONCEAL
Radio noise network sisters on heartbeats.
Unix style
Constructivism
Capability
Autodidactism
Constructionism
Logistics
Systems should
Fail Fast
Fail early
Halt on failure
The laws of thought are inconsistent!
Paradigm Shift
Semantic Integration
Laws of logic revised to tolerate inconsistency
Progress not Perfection
libevent
Unix signal
inode
inotify
Clutch
Omen
Node (networking)
Construction and management simulation
Multiprocessing
Romero
Keep it Simple
Principate
Constitution of the Martian Empire.
Competitive learning
Trajan’s Column
Overlords
Nonpreemptive multitasking
ORGs
Incompleteness means Inconsistency
Let it crash!
Reliable Organisms from Unreliable Components
Never certain
ORG’s for Robust privacy-friendly Cloud Forest Computing.
Tropical Cloud Forest Distributed Artificial Intelligent.
Cebus Artificial Monkeys
Caesar, had everything to do at one time
Scalability
Coherence
Automate stuff with monkeys
Machiavelli
Archetype
Flocks
Monkey Mirrors
Checks and balances
Opposite running course
Messages and Signaling
Innovation
Python
Dispatch systems
Coherent structure
The Key to software fault-tolerance
The big idea is messaging
ZeroMQ Infrastructure
Devices
zmq.proxy
Add a resource
Let it crash
Treehouse
Colony
Pantheon
How we organize
Problems ego and founders
Client-Server again
Some notes on Jupyter
Messages in Jupyter
Messaging for Parallel Computing
The Controller
The Hub
Registration (ROUTER)
Heartbeat
Notification (PUB)
Schedulers
Control Messages
A book that deserves burning
Scale the stuff up
Node Coordination
Architecture of a single node (overlord)
The beauty of scaling things up
Some things about ZeroMQ messages.
Components and Services
Peering
Overlord Tasks Router
The Name Ceremony (and more on why names are complicated).
Random nonsense
Load balancer
Agent Actions (AI)
Task Scheduler Algorithms
Dynamic Feedback Load balancing Scheduler
Cluster (Centuria)
Cluster Features
What runs a virtual imp?
Don't make matters worse
Ghost in the Shell
What is this all about
Inbound Campaigns
Outbound Campaigns
Campaign Monitor
Measurement
Python Central Logging with ZMQ
Interaction using messages
Conway’s law
Resource system
Organization Patterns
Enterprise Business Plan
What is?
Want us to manage I/O FUN for you?
About User Story
Errors
Thing on this stuff for a second
Grid Cube Computing
Overview
Cubes
Producer-Consumer Problem
Wittgenstein.
Confessions
Wittgenstein, Tractatus Logico-Philosophicus
Fail Fast
Messages
Processor
Honeycomb
honeycomb geometry
Classification
Honeycomb structure
Tessellation
M.C. Escher
Tesseract Cubes
Tiling window manager
i3 window manager
Liveness
C History
Unix Philosophy
More from quake
Amdahl's law
Conway’s law
Computer multitasking
Scheduling
Coroutine
Non-preemptive multitasking
Behavior
Batch processing
Task scheduler
Overview
Notes on Task Scheduler
Batch queuing for clusters
Batch window
Internet bot
LXC Container Cubes
Cgroups
Linux-based containers
Cloud forest analogy
Ten laws of Physics of People
Abstraction
We need something like ZeroMQ
Messaging Patterns
Remember
Pipes
Plumbers
Handyman tips
Sell X
Make your mind up
The Method
Important note
What is a businnes plan?
Names
Causality
Entropy
URI’s are bad
Used hashes instead of names
Note on Julia
Julia Tasks “Coroutines”
Julia Core Task operation
Tasks and events
Task states
Julia Parallel Computing
Data Movement
Synchronization With Remote References
Tasks and Parallel Computing
General Parallel Computing
Inconsistency Robustness
Empresas
Old man Aristotle
Construction
Lua
Lua Features
Lua Internals
Lua C API
About Lua
Principle of least privilege
Coroutine
Comparasion with subroutines
Subroutine
Coroutine Common uses
Nonpreemptive Multitasking
Coroutines in Lua
Yielding
Lua Coroutines
Campaigns
Accounts
Higher-order function
Blizzard Linked lists
Python Function decorators
Function Decorators
Linked list again
Doubly linked list
Related Data structures
Concurrent
Python multiprocessing pools
Linux Containers
LXC
LXD
LXCFS
CGManager
Clustering
Streaming clustering
Iterator
External iterator
Generators
Python iterators
Generator
Bit
Bit
Application
Floating point precision
Floating point decimal precision
Behavior
Management
System
Institution
Conway’s law
Amdahl’s Law
Semantics
Denotation
Semiotics
Semiosis
Queue
Some words on Queues
Creativity
Python Process-based parallelism
Pipes and queues
More Message passing
Fundamentally similar
Actors
Actor Misunderstanding
Idempotence
Carrier
Introducing Organizations
Interaction creates reality
Cube
Client-Server model
Client and server roles
Client and server communication
Clients and Servers Exchange Messages
Inter-process communication
Omnibus
Quakeworld network
Reliable messages from quakeworld engine
Semantic integration
Machine
Modern 1704 meaning:
Mecha an Auto
Control System
Remainder
LXC
Goal of LXC
LXC Requirements
Quake 3 Arena
Middleware
Open Telecom Platform
Design patterns
0MQ
0MQ Patterns
Blob of data
Wire protocol
Wire protocol functionality
Aphorism
Aforismo
Aforismos y Axiomas
Hamilton
Construct Spawn Execute
Spawn Daemons Faster
Daemon Portability and Infrastricture Flexibility
Dynamic Update, Change and Scale Daemons
Command
Imperative programming
Procedural programming
Recurrent Neural Network
Modularity
Focus
On Logic
Library
Declarative programming
Parallel Computing
Command pattern
Unix
C
Structured programming
Read-eval print loop
Shell
Voice user interface
Syntax
Namespace
A Web Crawler
The task
Coordinating Coroutines
Conclusion
Stuff fails deal with it
Tandem
The goal
Solr send me to the sun
Monitor features
The Twelve Truths
Why the computer stop and what can be done about it
Latency
Spawning Aqueducts
Treehouse
Vitruvius
De aquaeductu
Aqueduct Distribution
Tasks
Business process management
Foresight
In management
Stochastic process
Fundamentals of stochastic model
Stationary process
Modular constructivism
Bio-inspired techniques
Multitier architecture
Modular constructivism
Multipath routing
Modules
Properties of the system
Overlord Protocol
NGINX and the moon
We build trees of things
Capuchins
Spider Monkeys
Fission-fusion society
Frugivore
Mutualism
Human-based computation game or game with a purpose
Node
vi
Mode
Maslow’s hierarchy of needs
Linux Law
i3 window manager again
A workstation
Ghost in the Daemon
A concurrent web spider
Messages
Advice
Be consistent
Keep it simple
Be explicit
Maintenance
System
Error handling
Routers
Recap of request-reply
Identities and addresses
On Overlord
Business intelligence
The System evolved
First Principles
We don’t do defensive programming
Message passing
Error handling
The system must never go down!
Code handling
Distribution
Robust systems
A/B testing
Yokozuna
Deep Neural networks
Universal list of commands
Artificial cloud forest
On recruit
Marian reforms
The structure
On promotions
File Descriptor
Spool
Design School
Asynchronous network programing
Architecture
epoll
Gateways
Introducing Clien-server
Other process Fix Error
Let It Crash
Get Some Other to Fix It
Orchestration
Orchestration is Critical
Automation
Schneirder
Armstrong
B is for binary
Unit order
Cloud Forest Buildings
Imps Unit Agents
Martian Adventure
Inventory
Gameplay notes
Online
Lore
Daemon ghost’s
Some Characters
Environment
Strategy
Hopper Networks
Stochastic process
K-means clustering
Bootstrapping
.conf files
YAML
Quadtree
Octree
k-d tree
Campaign setting
Error handling Semantics
Messages and error signals
Receipt of an error signal
Explicit error signals
Untrappeble exit signals
Creating links
groups of Processes that all Die together
Seatting Up a Firewall
Monitors
Nodes on Adventure
Items
Gameplay Features
Fountains
What gods stuff
Arena
Collective URI design experience
Resource Design
OTP
OTP Powers
Erlang gen_server
Writting a gen_server module
Abstract
Making Systems
OTP
Trees
Behaviors
Standard Behaviours
Applications
Standard Streams
HTTP Codes
SIP Codes
HTTP request Methods
SIP request methods
HTTP Response Codes
Status Codes Overview
Tornado
Tornado flow
Creating webhooks
Enterprise
Erros and bugs
Think on this stuff
Generalizing fault-tolerant
Let it crash
Software failure
Context
Rest Architecture
Resources and resource identifiers
Resource representations
Self-descrioptive messages
Cluster analysis
Voronoi diagram
Lloyd’s algorithm
Learning to classify tags
Similarity
Clustering
K-means
Data Warangling
Ceres
Some random stuff
Probability
Random variable
Stochastic process
Event
Normal Distribution
Pattern recognition
Pattern Recognition Algoritms
Centroid
Objects
We live in a multi plant solar system
Multiprocessing
GIL
PI Monte Carlo
Clusters
Benefits of clustering
Multiple dispatch
Undestanding dispatch
Function names
ZeroMQ Socket types
Towards an Ideal Solution
Process monitoring
Connectionism
Backpropagation
Water is the driving force of all nature
Pipeline
The idea behind backpropagation
Sketch on a single case
Backpropagation dE/dY
On two approaches to computer perception














